<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zycin | GeekBlog</title>
<meta name="description" content="不忘初心  方得始终" />
<link rel="shortcut icon" href="https://fastt.cn/favicon.ico?v=1573109541766">
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css"> -->
<link rel="stylesheet" href="https://unpkg.zhimg.com/katex@0.10.0/dist/katex.min.css" />
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://fastt.cn/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Zycin | GeekBlog - Atom Feed" href="https://fastt.cn/atom.xml">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-150684183-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-150684183-1');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://fastt.cn">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://fastt.cn/images/avatar.png?v=1573109541766" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Zycin | GeekBlog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-grunt">一、 Grunt</a>
<ul>
<li><a href="#1grunt%E7%AE%80%E4%BB%8B">1．grunt简介</a></li>
<li><a href="#2%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">2．快速入门</a>
<ul>
<li><a href="#1-%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85-grunt-cli">1)  全局安装 grunt-cli</a></li>
<li><a href="#2-%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85grunt">2)  本地安装grunt</a></li>
<li><a href="#3gruntfile%E6%96%87%E4%BB%B6">3)	Gruntfile文件</a></li>
<li><a href="#wrapper-%E5%87%BD%E6%95%B0">&quot;wrapper&quot; 函数</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE">项目和任务配置</a></li>
<li><a href="#%E5%8A%A0%E8%BD%BD-grunt-%E6%8F%92%E4%BB%B6%E5%92%8C%E4%BB%BB%E5%8A%A1">加载 Grunt 插件和任务</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1">自定义任务</a></li>
</ul>
</li>
<li><a href="#3%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D">3．插件介绍</a>
<ul>
<li><a href="#4%E5%90%88%E5%B9%B6js-concat">4)	合并js: concat</a></li>
<li><a href="#5%E5%8E%8B%E7%BC%A9js-uglify">5)	压缩js: uglify</a></li>
<li><a href="#6js%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5-jshint">6)	js语法检查: jshint</a></li>
<li><a href="#7%E5%8E%8B%E7%BC%A9csscssmin">7)	压缩css：cssmin</a></li>
<li><a href="#8watch%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9B%91%E5%90%AC">8)	watch自动化监听</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-gulp">二、	Gulp</a>
<ul>
<li><a href="#4%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">4．快速入门</a>
<ul>
<li><a href="#9node%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B">9)	Node环境检测</a></li>
<li><a href="#10%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE">10)	搭建测试项目</a></li>
<li><a href="#11%E5%AE%89%E8%A3%85gulp">11)	安装gulp</a></li>
<li><a href="#12%E5%88%9B%E5%BB%BAgulpfile%E6%96%87%E4%BB%B6">12)	创建gulpfile文件</a></li>
</ul>
</li>
<li><a href="#5%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6">5．使用插件</a>
<ul>
<li><a href="#13node%E8%BD%AC%E6%8D%A2%E6%B5%81">13)	Node转换流</a></li>
<li><a href="#14%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%88%97%E8%A1%A8">14)	常用插件列表</a>
<ul>
<li><a href="#css%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8F%92%E4%BB%B6">CSS相关的插件</a></li>
<li><a href="#html%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6">HTML相关插件</a></li>
<li><a href="#%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6">图片相关插件</a></li>
<li><a href="#requirejs%E6%A8%A1%E5%9D%97%E4%BC%98%E5%8C%96">requirejs模块优化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6%E9%9D%9E%E6%8F%92%E4%BB%B6%E5%BA%94%E7%94%A8">6．非插件应用</a>
<ul>
<li><a href="#15gulpif%E6%9D%A1%E4%BB%B6%E6%8F%92%E4%BB%B6">15)	gulpif条件插件</a></li>
<li><a href="#16through2%E5%86%85%E8%81%94%E6%8F%92%E4%BB%B6">16)	through2内联插件</a></li>
</ul>
</li>
<li><a href="#7%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1">7．创建任务</a>
<ul>
<li><a href="#17%E5%AF%BC%E5%87%BA%E4%BB%BB%E5%8A%A1">17)	导出任务</a></li>
<li><a href="#18%E7%BB%84%E5%90%88%E4%BB%BB%E5%8A%A1">18)	组合任务</a></li>
</ul>
</li>
<li><a href="#8%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C">8．异步执行</a>
<ul>
<li><a href="#19%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90%E9%80%9A%E7%9F%A5">19)	任务完成通知</a></li>
<li><a href="#20%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B">20)	返回值类型</a></li>
</ul>
</li>
<li><a href="#9global%E8%AF%A6%E8%A7%A3">9．global详解</a>
<ul>
<li><a href="#21%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%87%E6%AE%B5%E4%B8%8E%E5%88%86%E9%9A%94%E7%AC%A6">21)	字符串片段与分隔符</a></li>
<li><a href="#22%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6-%E4%B8%80%E4%B8%AA%E6%98%9F%E5%8F%B7">22)	特殊字符： * (一个星号)</a></li>
<li><a href="#23%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6-%E4%B8%A4%E4%B8%AA%E6%98%9F%E5%8F%B7">23)	特殊字符： ** (两个星号)</a></li>
<li><a href="#24%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6-%E5%8F%96%E5%8F%8D">24)	特殊字符： ! (取反)</a></li>
</ul>
</li>
<li><a href="#10%E7%9B%91%E5%90%AC%E7%8A%B6%E6%80%81">10．监听状态</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"><div
			class="animated fadeInLeft social-container"
			style="animation-delay: 0.6s"
		>
			<a
				href="https://github.com/zycin/"
				target="_blank"
				class="text-xl text-gray-400 font-light hover:text-gray-900"
			>
				<i class="remixicon-github-line"></i>
			</a>

			<a
				href="http://wpa.qq.com/msgrd?v=3&amp;uin=785227561&amp;site=qq&amp;menu=yes"
				target="_blank"
				class="text-xl text-gray-400 font-light hover:text-gray-900"
			>
				<i class="remixicon-qq-line"></i>
			</a>
		</div>

Powered by <a href="https://github.com/zycin" target="_blank">Zycin</a></div>
    <a class="rss" href="https://fastt.cn/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">自动化构建</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-10-26 / 28 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://fastt-1252391792.file.myqcloud.com/builder.jpg" alt="">
        
        <div class="post-content yue">
          <p>前端自动化构建工具  <code>grunt</code>和<code>gulp</code>的使用<br>
begin enjoy👇</p>
<!-- more -->
<h1 id="一-grunt">一、 Grunt</h1>
<h2 id="1grunt简介">1．grunt简介</h2>
<p>grunt是一个基于nodeJS的命令行工具，通过其丰富而强大的插件执行一系列与前端自动化构建相关任务，例如：文件合并、压缩、脚本验证、less和sass预编译等。使用grunt可以实现项目更可靠的运行，有效提升项目部署的效率。</p>
<p>grunt基于nodejs，它使用CMD的模块加载机制并且使用npm库中的grunt插件，所有grunt生态插件都以包的形式发布到了npm平台。grunt插件包以<code>grunt-contrib-</code>和<code>grunt-</code>开头，前者为grunt官方发布的插件包，后者则为第三方用户编写的包。</p>
<p>使用前检查项目环境中是否有安装的node环境：<code>node -v</code></p>
<h2 id="2快速入门">2．快速入门</h2>
<p>使用grunt前，需创建一个简单的测试用例：grunt_app。目录文件结构如下：</p>
<pre><code>|- dist----------目标文件夹
|- src------------源码文件夹   
    |- js---------------js源文件夹
    |- css--------------css源文件夹
|- index.html-----测试文件
|- Gruntfile.js---grunt配置文件(注意首字母大写)
|- package.json---项目包配置文件
</code></pre>
<h3 id="1-全局安装-grunt-cli">1)  全局安装 grunt-cli</h3>
<p>你需要先将Grunt命令行（CLI）安装到全局环境中。安装时可能需要使用sudo（针对OSX、*nix、BSD等系统中）权限或者作为管理员（对于Windows环境）来执行以下命令：</p>
<pre><code class="language-shell">npm install -g grunt-cli
</code></pre>
<p>上述命令执行完后，<code>grunt</code> 命令就被加入到你的系统路径中了，以后就可以在任何目录下执行此命令了。<br>
注意，安装<code>grunt-cli</code>并不等于安装了 Grunt！Grunt CLI的任务很简单：调用与<code>Gruntfile</code>在同一目录中的Grunt。这样带来的好处是允许你在同一个系统上同时安装多个版本的 Grunt。</p>
<p>每次运行<code>grunt</code> 时，他就利用node提供的<code>require()</code>系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行<code>grunt</code> 。<br>
如果找到一份本地安装的 Grunt，CLI就将其加载，并传递<code>Gruntfile</code>中的配置信息，然后执行你所指定的任务。</p>
<h3 id="2-本地安装grunt">2)  本地安装grunt</h3>
<p>本地安装grunt，并运行构建项目命令。初始化运行grunt指令，会提示Warning: Task &quot;default&quot; not found。需要在根地址中添加<code>Grantfile.js</code>文件并配置default任务。</p>
<pre><code class="language-shell">npm install grunt --save-dev
grunt
</code></pre>
<h3 id="3gruntfile文件">3)	Gruntfile文件</h3>
<p><code>Gruntfile.js</code> 或 <code>Gruntfile.coffee</code> 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和<code>package.json</code>文件在同一目录层级，并和项目源码一起加入源码管理器。<br>
Gruntfile由以下几部分构成：</p>
<ul>
<li>
<p>&quot;wrapper&quot; 函数</p>
</li>
<li>
<p>项目与任务配置</p>
</li>
<li>
<p>加载grunt插件和任务</p>
</li>
<li>
<p>自定义任务<br>
在下面列出的这个 <code>Gruntfile</code> 中，<code>package.json</code>文件中的项目元数据（metadata）被导入到 Grunt 配置中， <a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 插件中的<code>uglify</code> 任务（task）被配置为压缩（minify）源码文件并依据上述元数据动态生成一个文件头注释。当在命令行中执行 <code>grunt</code> 命令时，<code>uglify</code> 任务将被默认执行。</p>
</li>
</ul>
<pre><code class="language-js">module.exports = function(grunt) {
  // Project configuration.
  grunt.initConfig({
    pkg: grunt.file.readJSON('package.json'),
    uglify: {
      options: {
        banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\n'
      },
      build: {
        src: 'src/&lt;%= pkg.name %&gt;.js',
        dest: 'build/&lt;%= pkg.name %&gt;.min.js'
      }
    }
  });

  // 加载包含 &quot;uglify&quot; 任务的插件。
  grunt.loadNpmTasks('grunt-contrib-uglify');

  // 默认被执行的任务列表。
  grunt.registerTask('default', ['uglify']);

};
</code></pre>
<p>前面已经向你展示了整个 <code>Gruntfile</code>，接下来将详细解释其中的每一部分。</p>
<h3 id="wrapper-函数">&quot;wrapper&quot; 函数</h3>
<p>每一份 <code>Gruntfile</code> （和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：</p>
<pre><code class="language-js">module.exports = function(grunt) {
  // Do grunt-related things in here
};
</code></pre>
<h3 id="项目和任务配置">项目和任务配置</h3>
<p>大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给<a href="https://www.gruntjs.net/grunt#grunt.initconfig">grunt.initConfig</a> 方法。</p>
<p>在下面的案例中，<code>grunt.file.readJSON('package.json')</code> 将存储在<code>package.json</code>文件中的JSON元数据引入到grunt config中。 由于<code>&lt;% %&gt;</code>模板字符串可以引用任意的配置属性，因此可以通过这种方式来指定诸如文件路径和文件列表类型的配置数据，从而减少一些重复的工作。</p>
<p>你可以在这个配置对象中(传递给initConfig()方法的对象)存储任意的数据，只要它不与你任务配置所需的属性冲突，否则会被忽略。此外，由于这本身就是JavaScript，你不仅限于使用JSON；你可以在这里使用任意的有效的JS代码。如果有必要，你甚至可以以编程的方式生成配置。</p>
<p>与大多数task一样，<a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 插件中的<code>uglify</code> 任务要求它的配置被指定在一个同名属性中。在这里有一个例子, 我们指定了一个<code>banner</code>选项(用于在文件顶部生成一个注释)，紧接着是一个单一的名为<code>build</code>的uglify目标，用于将一个js文件压缩为一个目标文件。</p>
<pre><code class="language-js">// Project configuration.
grunt.initConfig({
  pkg: grunt.file.readJSON('package.json'),
  uglify: {
    options: {
      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\n'
    },
    build: {
      src: 'src/&lt;%= pkg.name %&gt;.js',
      dest: 'build/&lt;%= pkg.name %&gt;.min.js'
    }
  }
});
</code></pre>
<h3 id="加载-grunt-插件和任务">加载 Grunt 插件和任务</h3>
<p>像 <a href="https://github.com/gruntjs/grunt-contrib-concat">concatenation</a>、[minification]、<a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 和 <a href="https://github.com/gruntjs/grunt-contrib-jshint">linting</a>这些常用的任务（task）都已经以<a href="https://github.com/gruntjs">grunt插件</a>的形式被开发出来了。只要在 <code>package.json</code> 文件中被列为dependency（依赖）的包，并通过<code>npm install</code>安装之后，都可以在<code>Gruntfile</code>中以简单命令的形式使用：</p>
<pre><code class="language-js">// 加载能够提供&quot;uglify&quot;任务的插件。
grunt.loadNpmTasks('grunt-contrib-uglify');
</code></pre>
<p><strong>注意：</strong> <code>grunt --help</code> 命令将列出所有可用的任务。</p>
<h3 id="自定义任务">自定义任务</h3>
<p>通过定义 <code>default</code> 任务，可以让Grunt默认执行一个或多个任务。在下面的这个案例中，执行 <code>grunt</code> 命令时如果不指定一个任务的话，将会执行<code>uglify</code>任务。这和执行<code>grunt uglify</code> 或者 <code>grunt default</code>的效果一样。<code>default</code>任务列表数组中可以指定任意数目的任务（可以带参数）。</p>
<pre><code class="language-js">// Default task(s).
grunt.registerTask('default', ['uglify']);
</code></pre>
<p>如果Grunt插件中的任务（task）不能满足你的项目需求，你还可以在<code>Gruntfile</code>中自定义任务（task）。例如，在下面的 <code>Gruntfile</code> 中自定义了一个<code>default</code> 任务，并且他甚至不依赖任务配置：</p>
<pre><code class="language-js">module.exports = function(grunt) {

  // A very basic default task.
  grunt.registerTask('default', 'Log some stuff.', function() {
    grunt.log.write('Logging some stuff...').ok();
  });

};
</code></pre>
<p>特定于项目的任务不必在 <code>Gruntfile</code> 中定义。他们可以定义在外部<code>.js</code> 文件中，并通过<a href="https://www.gruntjs.net/grunt/#grunt.loadtasks">grunt.loadTasks</a> 方法加载。</p>
<h2 id="3插件介绍">3．插件介绍</h2>
<ul>
<li>grunt官网的插件列表页面 http://www.gruntjs.net/plugins</li>
<li>插件分类:
<ul>
<li>grunt团队贡献的插件 : 插件名大都以contrib-开头</li>
<li>第三方提供的插件 : 大都不以contrib-开头</li>
</ul>
</li>
<li>常用的插件:
<ul>
<li>grunt-contrib-clean——清除文件(打包处理生成的)</li>
<li>grunt-contrib-concat——合并多个文件的代码到一个文件中</li>
<li>grunt-contrib-uglify——压缩js文件</li>
<li>grunt-contrib-jshint——javascript语法错误检查；</li>
<li>grunt-contrib-cssmin——压缩/合并css文件</li>
<li>grunt-contrib-htmlmin——压缩html文件</li>
<li>grunt-contrib-imagemin——压缩图片文件(无损)</li>
<li>grunt-contrib-copy——复制文件、文件夹</li>
<li><strong>grunt-contrib-requirejs</strong>——合并压缩requirejs管理的所有js模块文件</li>
<li>grunt-contrib-watch——实时监控文件变化、调用相应的任务重新执行</li>
</ul>
</li>
</ul>
<h3 id="4合并js-concat">4)	合并js: concat</h3>
<ul>
<li>
<p>命令:</p>
<pre><code>npm install grunt-contrib-concat --save-dev
</code></pre>
</li>
<li>
<p>编码:</p>
<ul>
<li>
<p>src/js/test1.js</p>
<pre><code>(function () {
  function add(num1, num2) {
    return num1 + num2;
  }
  console.log(add(10, 20));
})();
</code></pre>
</li>
</ul>
</li>
<li>
<p>src/js/test2.js</p>
<pre><code>(function () {
  var arr = [2,3,4].map(function (item, index) {
    return item+1;
  });
  console.log(arr);
})();
}
</code></pre>
<ul>
<li>
<p>配置: Gruntfile.js</p>
<ul>
<li>
<p>配置任务:</p>
<pre><code>concat: {
    options: { //可选项配置
      separator: ';'   //使用;连接合并
    },
    build: { //此名称任意
      src:  [&quot;src/js/*.js&quot;],  //合并哪些js文件
      dest: &quot;build/js/built.js&quot; //输出的js文件
    }
  }
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>加载插件:</p>
<pre><code>grunt.loadNpmTasks('grunt-contrib-concat');
</code></pre>
<ul>
<li>
<p>注册任务:</p>
<pre><code>grunt.registerTask('default', ['concat']);
</code></pre>
</li>
<li>
<p>命令:</p>
</li>
</ul>
<pre><code>grunt   //会在build下生成一个built.js
</code></pre>
</li>
</ul>
<h3 id="5压缩js-uglify">5)	压缩js: uglify</h3>
<ul>
<li>
<p>下载</p>
<pre><code>npm install grunt-contrib-uglify --save-dev
</code></pre>
</li>
<li>
<p>配置: Gruntfile.js</p>
<ul>
<li>
<p>配置任务:</p>
<pre><code>pkg : grunt.file.readJSON('package.json'),
uglify : {
  options: {  //不是必须的
    banner: '/*! &lt;%= pkg.name %&gt; - v&lt;%= pkg.version %&gt; - ' +
    '&lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */'
  },
  build: {
    files: {
      'build/js/built-&lt;%=pkg.name%&gt;-&lt;%=pkg.version%&gt;.min.js': ['build/js/built.js']
    }
  }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>加载任务:</p>
<pre><code>grunt.loadNpmTasks('grunt-contrib-uglify');
</code></pre>
<ul>
<li>
<p>注册任务:</p>
<pre><code>grunt.registerTask('default', ['concat', 'uglify']);
</code></pre>
</li>
<li>
<p>命令:</p>
</li>
</ul>
<pre><code>grunt   //会在build下生成一个压缩的js文件
</code></pre>
</li>
</ul>
<h3 id="6js语法检查-jshint">6)	js语法检查: jshint</h3>
<ul>
<li>
<p>命令:</p>
<pre><code>npm install grunt-contrib-jshint --save-dev
</code></pre>
</li>
<li>
<p>编码: .jshintrc</p>
<pre><code>{
  &quot;curly&quot;: true,
  &quot;eqeqeq&quot;: true,
  &quot;eqnull&quot;: true,
  &quot;expr&quot; : true,
  &quot;immed&quot;: true,
  &quot;newcap&quot;: true,
  &quot;noempty&quot;: true,
  &quot;noarg&quot;: true,
  &quot;regexp&quot;: true,
  &quot;browser&quot;: true,
  &quot;devel&quot;: true,
  &quot;node&quot;: true,
  &quot;boss&quot;: false,
  
  //不能使用未定义的变量
  &quot;undef&quot;: true,
  //语句后面必须有分号
  &quot;asi&quot;: false,
  //预定义不检查的全局变量
  &quot;predef&quot;: [ &quot;define&quot;, &quot;BMap&quot;, &quot;angular&quot;, &quot;BMAP_STATUS_SUCCESS&quot;]
}
</code></pre>
</li>
<li>
<p>修改src/js/test1.js</p>
<pre><code>(function () {
  function add(num1, num2) {
    num1 = num1 + num3
    return num1 + num2;
  }
  console.log(add(10, 20));
})();
</code></pre>
</li>
<li>
<p>配置 : Gruntfile.js</p>
<ul>
<li>
<p>配置任务:</p>
<pre><code>jshint : {
  options: {
    jshintrc : '.jshintrc' //指定配置文件
  },
  build : ['Gruntfile.js', 'src/js/*.js'] //指定检查的文件
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>加载任务:</p>
<pre><code>grunt.loadNpmTasks('grunt-contrib-jshint');
</code></pre>
<ul>
<li>
<p>注册任务:</p>
<pre><code>grunt.registerTask('default', ['concat', 'uglify', 'jshint']);
</code></pre>
</li>
<li>
<p>命令:</p>
</li>
</ul>
<pre><code>grunt   //提示变量未定义和语句后未加分号 --&gt;修改后重新编译
</code></pre>
</li>
</ul>
<h3 id="7压缩csscssmin">7)	压缩css：cssmin</h3>
<ul>
<li>
<p>安装:</p>
<pre><code>npm install grunt-contrib-cssmin --save-dev
</code></pre>
</li>
<li>
<p>编码:</p>
<ul>
<li>
<p>test1.css</p>
<pre><code>#box1 {
  width: 100px;
  height: 100px;
  background: red;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>test2.css</p>
<pre><code>#box2 {
  width: 200px;
  height: 200px;
  background: blue;
}
</code></pre>
<ul>
<li>
<p>index.html</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;build/css/output.min.css&quot;&gt;
&lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;box2&quot;&gt;&lt;/div&gt;
</code></pre>
</li>
<li>
<p>配置 : Gruntfile.js</p>
<ul>
<li>
<p>配置任务:</p>
<pre><code>cssmin:{
  options: {
    shorthandCompacting: false,
    roundingPrecision: -1
  },
  build: {
    files: {
        'build/css/output.min.css': ['src/css/*.css']
    }
  }
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>加载任务:</p>
<pre><code>grunt.loadNpmTasks('grunt-contrib-cssmin');
</code></pre>
<ul>
<li>
<p>注册任务:</p>
<pre><code>grunt.registerTask('default', ['concat', 'uglify', 'jshint', 'cssmin']);
</code></pre>
</li>
<li>
<p>命令:</p>
</li>
</ul>
<pre><code>grunt    //在build/css/下生成output.min.css
</code></pre>
</li>
</ul>
<h3 id="8watch自动化监听">8)	watch自动化监听</h3>
<ul>
<li>
<p>命令: npm install grunt-contrib-watch --save-dev</p>
</li>
<li>
<p>配置 : Gruntfile.js</p>
<ul>
<li>
<p>配置任务:</p>
<pre><code>watch : {
  scripts : {
    files : ['src/js/*.js', 'src/css/*.css'],
    tasks : ['concat', 'jshint', 'uglify', 'cssmin'],
    options : {spawn : false}  
  }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>加载任务:</p>
<pre><code>grunt.loadNpmTasks('grunt-contrib-watch');
</code></pre>
<ul>
<li>
<p>注册任务:</p>
<pre><code>grunt.registerTask('default', ['concat', 'uglify', 'jshint', 'watch']);
改进：grunt.registerTask('myWatch', ['default','watch']);
</code></pre>
</li>
<li>
<p>命令:</p>
</li>
</ul>
<pre><code>grunt   //控制台提示watch已经开始监听, 修改保存后自动编译处理
</code></pre>
</li>
</ul>
<h1 id="二-gulp">二、	Gulp</h1>
<h2 id="4快速入门">4．快速入门</h2>
<h3 id="9node环境检测">9)	Node环境检测</h3>
<p>如果你先前将 gulp 安装到全局环境中了，请执行 npm rm --global gulp 将 gulp 删除再继续以下操作。接下来检查node、npm、npx是否安装正确：</p>
<pre><code class="language-shell">node -v
npm -v
npx -v
</code></pre>
<h3 id="10搭建测试项目">10)	搭建测试项目</h3>
<pre><code>|----dist 构建之后的代码，实际部署的线上环境
|----src 开发时的代码，适合阅读和修改
|----|----js
|----|----css
|----index.html
</code></pre>
<h3 id="11安装gulp">11)	安装gulp</h3>
<ul>
<li><code>npm install gulp-cli --global</code></li>
<li><code>npm install gulp --save-dev</code></li>
</ul>
<h3 id="12创建gulpfile文件">12)	创建gulpfile文件</h3>
<p>创建<code>gulpfile.js</code>文件测试gulp指令：<br>
gulpfile 是项目目录下名为 gulpfile.js ，在运行 gulp 命令时会被自动加载。这个文件用来编写gulp程序，也就是自动化的具体任务。文件中可以包含纯JavaScript 代码或 Node 模块。</p>
<pre><code class="language-js">//任何导出的函数都将注册到 gulp 的任务（task）系统中
exports.default = function (cb) {
cb();  //每个任务是一个异步的javascript函数 需要cb标记状态
}
</code></pre>
<h2 id="5使用插件">5．使用插件</h2>
<h3 id="13node转换流">13)	Node转换流</h3>
<p>Gulp是基于流的操作，每个Gulp插件都是一个Node转换流（Transform Streams）。Gulp封装了读取文件流和输出流到文件的方法，插件用来在过程中转化流。转换流的插件需要放置封装的<code>pipe()</code>（pipeline管道）方法中。</p>
<p><code>src(源文件).pipe(插件操作).pipe(插件操作).dest(输出目标)</code></p>
<ul>
<li>src() 接受 glob参数，从文件系统中读取文件然后生成一个 Node 流（stream）。它将所有匹配的文件读取到内存中并通过流（stream）进行处理。由src()产生的流（stream）应当从任务（task）中返回并发出异步完成的信号，就如创建任务（task） 文档中所述。</li>
<li>pipe() 管道方法用于流转化的连接，通过传入插件操作数据流，每个插件应当只完成必要的工作。因此你可以把它们像构建块一样连接在一起。获得想要的结果可能需要把一组插件组合在一起使用。</li>
<li>dest() 接受一个输出目录作为参数，并且它还会产生一个 Node 流（stream），通常作为终止流（terminator stream）。当它接收到通过管道（pipeline）传输的文件时，它会将文件内容及文件属性写入到指定的目录中并且沿用之前的文件名。如果要重命名，需要在此之前使用rename插件修改。</li>
</ul>
<h3 id="14常用插件列表">14)	常用插件列表</h3>
<p>托管在 npm 上的插件标记有 &quot;gulpplugin&quot; 和 &quot;gulpfriendly&quot; 关键词 - 可以在<code>插件搜索页面</code>上浏览和搜索。在项目开发中，通常需要对html，css和js进行处理。特别注意，当代码经过转化后，原有文件中的路径和名字要作同步的修改，否则无法执行。<br>
Javascript相关插件</p>
<ul>
<li>
<p>gulp-concat	合并多个javascript文件为一个整体，需要指定一个新的名称。gulp不支持es6的模块合并，使用export和import会出错。它可以通过插件合并优化requirejs加载的模块。</p>
</li>
<li>
<p>gulp-uglify  压缩javascript代码，不会重命名</p>
</li>
<li>
<p>gulp-rename  重命名文件，它支持对象形式的配置参数</p>
<pre><code class="language-js">const gulp = require(&quot;gulp&quot;);
	// console.dir(gulp);
	
//从模块提取方法
const {src, dest} = gulp;

//加载gulp插件包
const concat = require(&quot;gulp-concat&quot;),
  uglify = require(&quot;gulp-uglify&quot;),
  rename = require(&quot;gulp-rename&quot;);

//注册默认任务
exports.default = function (cb) {
  //模块具体的执行动作，需要返回异步完成信号
  return src(&quot;./src/js/*.js&quot;)
    .pipe(concat(&quot;build.js&quot;))   //临时文件名
    .pipe(uglify()) //压缩文件
    .pipe(rename({extname : &quot;.min.js&quot;}))  //重新命名
    .pipe(dest(&quot;./dist/js&quot;));  //输出目标21	
}
</code></pre>
<h4 id="css相关的插件">CSS相关的插件</h4>
<ul>
<li>
<p>gulp-concat-css 合并多个css文件为一个整体</p>
</li>
<li>
<p>gulp-clean-css 压缩css代码，并设置兼容ie8</p>
</li>
<li>
<p>gulp-less 编译less代码文件，一般在合并压缩前编译less文件，然后统一的进行操作。</p>
<pre><code class="language-js">const {src, dest, series, parallel} = require(&quot;gulp&quot;);
const concatCss = require(&quot;gulp-concat-css&quot;),
    cleanCss = require(&quot;gulp-clean-css&quot;),
    rename = require(&quot;gulp-rename&quot;),
    lessCss = require(&quot;gulp-less&quot;);
    
//注册多个单一任务，可以使用module.exports
function css() {
        return src(&quot;./src/css/*.css&quot;)
            .pipe(concatCss(&quot;./css/build.css&quot;))
            .pipe(rename({extname : &quot;.min.css&quot;}))
            .pipe(cleanCss({compatibility:&quot;ie8&quot;}))
            .pipe(dest(&quot;./dist/&quot;));

}

function less() { 
      return src(&quot;src/less/*.less&quot;)
          .pipe(lessCSS())
          .pipe(dest(&quot;./src/css&quot;)); //自动加载名称
}
//以同步的方式 顺序执行列表任务
exports.default = series(less, css);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="html相关插件">HTML相关插件</h4>
<ul>
<li>
<p>gulp-htmlmin 压缩html代码，它能够帮助你优化html标签，并去除不必要的空白和注释。</p>
<pre><code class="language-js">function html() {
  return src(&quot;./src/html/*.html&quot;)
      .pipe(dest(&quot;./dist/html/&quot;))
      .pipe(src(&quot;src/**/*.html&quot;))
      .pipe(htmlmin({
          removeComments: true, //清除HTML注释
          collapseWhitespace: true, //压缩HTML
          collapseBooleanAttributes: true, //省略布尔属性的值
          removeEmptyAttributes: true, //删除所有空格作属性值
          removeScriptTypeAttributes: true, //删除&lt;script&gt;的type
          removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;的type
          minifyJS: true, //压缩页面JS
          minifyCSS: true //压缩页面CSS
      }))
      .pipe(dest(&quot;./dist/&quot;));17	
}
</code></pre>
</li>
</ul>
<h4 id="图片相关插件">图片相关插件</h4>
<ul>
<li>
<p>gulp-imagemin 压缩图片格式 <code>Minify PNG, JPEG, GIF and SVG images</code>减少图片体积，提高网络传输速率。</p>
<pre><code class="language-js">//图片压缩任务
function img() {
    return src(&quot;src/images/*&quot;)
        .pipe(imagemin({
        //优化等级默认为：3  取值范围：0-7 
        optimizationLevel: 5,
        //默认为false 无损压缩jpg图片
        progressive: true,
        //默认为false 隔行扫描gif进行渲染
        interlaced: true,
        //默认为false 多次优化svg直到完全优化
        // multipass: true
    }))
        .pipe(imagemin({
        progressive: true, //无损压缩JPG图片  
        svgoPlugins: [{
            removeViewBox: false
        }], //不移除svg的viewbox属性
        use: [pngquant()] //使用pngquant插件进行深度压缩  
    }))
      .pipe(dest(&quot;./dist/images/&quot;));39		
}
</code></pre>
</li>
</ul>
<h4 id="requirejs模块优化">requirejs模块优化</h4>
<ul>
<li>
<p>gulp-gulp-requirejs-optimize 优化合并requirejs的模块文件，将依赖模块注入主模块中，以此减少当前页面的http请求次数，提高加载效率。optimize插件只支持es5，需要先将模块中包含的es6语法进行转化。在管道方法中调用该插件时需要配置模块名和路径的关联映射，替代原先在主模块中使用require.config()配置的信息：</p>
<pre><code class="language-js">function js() {
    return src(&quot;./src/js/*.js&quot;)
        .pipe(requirejsOptimize({
        optimize: &quot;none&quot;,

        paths: {
            //依赖模块的路径列表
            &quot;jquery&quot;: &quot;../../node_modules/jquery/dist/jquery.min&quot;,
            &quot;header&quot;: &quot;./header&quot;,
            &quot;slide&quot;: &quot;../../node_modules/lautin-slide/slide&quot;,
            &quot;tab&quot;: &quot;../../node_modules/lautin-tab/tab&quot;,
            &quot;template&quot;: &quot;../../node_modules/art-template/lib/template-web&quot;,
            &quot;utils&quot;: &quot;./utils&quot;,
            &quot;jqzoom&quot;: &quot;./jqzoom-core&quot;,
            &quot;pagination&quot;: &quot;../../node_modules/lautin-pagination/libs/Pagination&quot;
        },
        //非规范模块设置
        shim: {
            'slide': {
                deps: [], //依赖模块
                exports: 'Slide' //导出接口
            },
            'tab': {
                deps: [],
                exports: 'Tab'
            },
            'pagination': {
                deps: [], //依赖模块
                exports: 'Pagination' //导出接口
            },
        },
        //不打包的静态文件
        excludeShallow: [
            'jquery', 'bootstrap', 'clockpicker', 'datetimepickerLang', 'clipboard', 'moment', 'datetimepicker', 'daterangepicker'
        ],
        preserveLicenseComments: false, //去掉头部版权声明
        removeCombined: false, //自动删除被合并过的文件
    }))
        .pipe(uglify()) //压缩
        .pipe(rename({ //重命名
        extname: &quot;.min.js&quot;
}))
        .pipe(dest(&quot;./dist/js/&quot;)); //输出	}
</code></pre>
</li>
<li>
<p>gulp-babel  javascript代码生成器，可以转化代码以及Polyfill 使用时需保证加载es6规范。接下来在管道方法中调用插件时添加配置presets。</p>
</li>
</ul>
<pre><code class="language-shell">cnpm install --save-dev gulp-babel@7 babel-core babel-preset-env
cnpm install babel-preset-es2015
</code></pre>
<pre><code class="language-javascript">babel({presets: ['es2015']})
</code></pre>
<ul>
<li>gulp-load-plugins 自动加载插件，无需手动引入 但前提需要先下载</li>
</ul>
<h2 id="6非插件应用">6．非插件应用</h2>
<p>并非 gulp 中的一切都需要用插件来完成。虽然它们是一种快速上手的方法，但许多操作都应当通过使用独立的功能模块或库来实现。<br>
插件应当总是用来转换文件的。其他操作都应该使用（非插件的） Node 模块或库来实现。</p>
<pre><code class="language-js">//并非基于插件，所有的node模块都支持
const fs = require(&quot;fs&quot;);
exports.default = function (cb) {
    //所有可执行的node代码都可以
    fs.unlinkSync(&quot;./dist/js/build.min.js&quot;); //删除已有的合并文件
    cb();7	
}
</code></pre>
<p>复制文件操作：</p>
<pre><code class="language-js">const fs = require(&quot;fs&quot;);
	
exports.default = function (cb) {
    let source = &quot;./src/html/&quot;,
        target = &quot;./dist/html/&quot;;
    //检测如果目录不存在 则创建之
    if (!fs.existsSync(target)) fs.mkdirSync(target, {
        recursive: true, //递归创建
    });

    const files = fs.readdirSync(source);
    files.forEach((item) =&gt; {
        let filename = path.join(source, item);
        let buffer = fs.readFileSync(filename);
        fs.writeFileSync(path.join(target, item), buffer);
    });
  
    //可以直接使用src和dest方法直接转化
    //return src(source)
    // .pipe(dest(target));
}
</code></pre>
<h3 id="15gulpif条件插件">15)	gulpif条件插件</h3>
<p>因为插件的操作不应该针对特定文件类型，因此你可能需要使用像<code>gulp-if</code>之类的插件来完成转换某些文件的操作。</p>
<pre><code class="language-js">function chk(file) {
//file为src中遍历出的每个文件对象
//file.history数组中存放了该文件或目录名
//只针对index.js文件的操作
return  file.history[0].endsWith(“index.js”);
}

src(“src/js/*.js”)
.pipe(gulpif(chk, concat()))
.dest()
</code></pre>
<h3 id="16through2内联插件">16)	through2内联插件</h3>
<h2 id="7创建任务">7．创建任务</h2>
<p>每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable (后面会详细讲解) 类型值的函数。由于某些平台的限制而不支持异步任务，因此 gulp 还提供了一个漂亮 替代品。<br>
任务（tasks）可以是 public（公开） 或 private（私有） 类型的。</p>
<ul>
<li>公开任务（Public tasks）：它指从 gulpfile 中被导出（export），可以通过 gulp 命令直接调用的任务。</li>
</ul>
<ul>
<li>私有任务（Private tasks）：它设计被用于内部使用，通常作为 series() 或 parallel() 组合的组成部分。一个私有（private）类型的任务（task）在外观和行为上和其他任务（task）是一样的，但是不能够被用户直接调用。如需将一个任务（task）注册为公开（public）类型的，只需从 gulpfile 中导出（export）即可。</li>
</ul>
<h3 id="17导出任务">17)	导出任务</h3>
<p>使用exports导出任务列表，每个任务即可以是一个字面量函数，也可以是已有函数的引用。可以通过重写module.exports将任务集合在一起。任务函数最好单独声明，这样便于组合式任务中引用它们。</p>
<pre><code class="language-js">const {series, parallel} = require(“gulp”);

function html()  {}
function css() {}
function js() {}

exports.html = html;
exports.css = css;
exports.js = js;
exports.default = parallel(html, css, js);

//使用module.exports重写
module.exports = {
    html,
    css,
    js43	}
</code></pre>
<h3 id="18组合任务">18)	组合任务</h3>
<p>除了指定的任务外，gulp命令初始化时会自动加载default任务，通常它是一个组合任务。在组合任务中，所有的任务函数必须独立定制以便接下来在series()和parallel()方法中引用它们。</p>
<pre><code class="language-js">const {src, dest, series, parallel} = require(&quot;gulp&quot;);	
const concatCSS = require(&quot;gulp-concat-css&quot;),
      rename = require(&quot;gulp-rename&quot;),
      lessCSS = require(&quot;gulp-less&quot;),
      cleanCSS = require(&quot;gulp-clean-css&quot;);

//注册多个单一任务，可以使用module.exports
module.exports = {
    concat (cb) {
        console.log(222);
        return src(&quot;./src/css/*.css&quot;)
            .pipe(concatCSS(&quot;./css/build.css&quot;))
            .pipe(rename({extname : &quot;.min.css&quot;}))
            .pipe(cleanCSS({compatibility:&quot;ie8&quot;}))
            .pipe(dest(&quot;./dist/&quot;));
    },

    less (cb) {
        console.log(111);
        return src(&quot;src/less/*.less&quot;)
            .pipe(lessCSS())
            .pipe(dest(&quot;./src/css&quot;)); //自动加载名称
    },
    default : series(less, concat), //顺序执行任务，保证合并文件中包含less编译文件
    default : parallel(less, concat),//异步执行任务，执行合并任务时less未必完成编译，合并文件中可能会丢失less文件
}
</code></pre>
<h2 id="8异步执行">8．异步执行</h2>
<p>Node 库以多种方式处理异步功能。最常见的模式是 error-first callbacks，但是你还可能会遇到 streams、promises、event emitters、child processes, 或 observables。gulp 任务（task）规范化了所有这些类型的异步功能。</p>
<h3 id="19任务完成通知">19)	任务完成通知</h3>
<p>当从任务（task）中返回 stream、promise、event emitter、child process 或 observable 时，成功或错误值将通知 gulp 是否继续执行或结束。如果任务（task）出错，gulp 将立即结束执行并显示该错误。<br>
当使用 series() 组合多个任务（task）时，任何一个任务（task）的错误将导致整个任务组合结束，并且不会进一步执行其他任务。当使用 parallel() 组合多个任务（task）时，一个任务的错误将结束整个任务组合的结束，但是其他并行的任务（task）可能会执行完，也可能没有执行完。</p>
<h3 id="20返回值类型">20)	返回值类型</h3>
<ul>
<li>
<p>返回stream，所有管道运行的任务，最终以输入输出流的形式 返回异步线程</p>
</li>
<li>
<p>返回Promise，一个Promise对象的实例</p>
</li>
<li>
<p>返回child process或者observable</p>
</li>
<li>
<p>使用callback，如果任务（task）不返回任何内容，则必须使用 callback 来指示任务已完成。在如下示例中，callback 将作为唯一一个名为 cb() 的参数传递给你的任务（task）。</p>
<pre><code class="language-js">function callbackError(cb) {
    // `cb()` should be called by some async work
    cb(new Error('kaboom'));
}
exports.default = callbackError;
</code></pre>
</li>
</ul>
<p>如需通过 callback 把任务（task）中的错误告知 gulp，请将 Error 作为 callback 的唯一参数。<br>
如果不使用前面提供到几种方式，你还可以将任务（task）定义为一个 async 函数，它将利用 promise 对你的任务（task）进行包装。这将允许你使用 await 处理 promise，并使用其他同步代码。</p>
<pre><code class="language-js">const fs = require('fs');

async function asyncAwaitTask() {
    const { version } = fs.readFileSync('package.json');
    console.log(version);
    await Promise.resolve('some result');
}

exports.default = asyncAwaitTask;
</code></pre>
<h2 id="9global详解">9．global详解</h2>
<h3 id="21字符串片段与分隔符">21)	字符串片段与分隔符</h3>
<p>字符串片段（segment）是指两个分隔符之间的所有字符组成的字符串。在 glob 中，分隔符永远是 / 字符 - 不区分操作系统 - 即便是在采用 \ 作为分隔符的 Windows 操作系统中。在 glob 中，\ 字符被保留作为转义符使用。<br>
如下， * 被转义了，因此，* 将被作为一个普通字符使用，而不再是通配符了。</p>
<h3 id="22特殊字符-一个星号">22)	特殊字符： * (一个星号)</h3>
<p>在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用。<br>
下面这个 glob 能够匹配类似 index.js 的文件，但是不能匹配类似 scripts/index.js 或 scripts/nested/index.js 的文件。</p>
<h3 id="23特殊字符-两个星号">23)	特殊字符： ** (两个星号)</h3>
<p>在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用。请确保适当地限制带有两个星号的 glob 的使用，以避免匹配大量不必要的目录。<br>
下面这个 glob 被适当地限制在 scripts/ 目录下。它将匹配类似 scripts/index.js、scripts/nested/index.js 和 scripts/nested/twice/index.js 的文件。</p>
<h3 id="24特殊字符-取反">24)	特殊字符： ! (取反)</h3>
<p>由于 glob 匹配时是按照每个 glob 在数组中的位置依次进行匹配操作的，所以 glob 数组中的取反（negative）glob 必须跟在一个非取反（non-negative）的 glob 后面。第一个 glob 匹配到一组匹配项，然后后面的取反 glob 删除这些匹配项中的一部分。如果取反 glob 只是由普通字符组成的字符串，则执行效率是最高的。</p>
<h2 id="10监听状态">10．监听状态</h2>
<p>gulp api 中的 watch() 方法利用文件系统的监控程序（file system watcher）将 globs 与 任务（task） 进行关联。它对匹配 glob 的文件进行监控，如果有文件被修改了就执行关联的任务（task）。如果被执行的任务（task）没有触发 异步完成 信号，它将永远不会再次运行了。<br>
此 API 的默认设置是基于通常的使用场景的，而且提供了内置的延迟和排队机制。</p>
<pre><code class="language-js">const {
    src,
    dest,
    series,
    parallel,
    watch,
} = require(&quot;gulp&quot;);

function less() {}
function css() {}
function transform() {}
function js() {}
function html() {}
function img() {}

//监听源文件 一旦发生改变执行全部任务 这样耗时长 没必要 
//watch(“src/*”, parelle(series(less, css), series(transform, js)))

//分别监听源文件的状态，实现热替换，在运行时更新各种模块而无需进行完全刷新
watch(&quot;src/css/*&quot;, series(less, css))
watch(&quot;src/js/*&quot;, series(transform, js))
watch(&quot;src/image/*&quot;, img)
watch(&quot;src/*.html&quot; html)
</code></pre>
<hr>
<p align="right">posted @ Zycin (非转载 来自个人学习资料整理)</p>
        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://fastt.cn/tag/gulp">
            <span class="flex-auto">gulp</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://fastt.cn/tag/grunt">
            <span class="flex-auto">grunt</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://fastt.cn/tag/build tool">
            <span class="flex-auto">build tool</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://fastt.cn/post/React1">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  React第一段
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://fastt.cn/post/regex">
                <h3 class="post-title">
                  正则表达式
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.zhimg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.zhimg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'f9c4cb98113788bb94e1',
    clientSecret: 'd271ed343d3af9b71c24dff543d9c3e1e4d70a4b',
    repo: 'zycin.github.io',
    owner: 'zycin',
    admin: ['zycin'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://fastt.cn/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
