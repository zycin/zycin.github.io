<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" >

<title>模块化和npm | Zycin | GeekBlog</title>
<meta name="description" content="不忘初心  方得始终">
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://fastt.cn/favicon.ico?v=1571708864065">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://fastt.cn/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



</head>

<body>
  <div id="app" class="main">

    <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://fastt.cn">
        <img src="https://fastt.cn/images/avatar.png?v=1571708864065" class="site-logo">
        <h1 class="site-title">Zycin | GeekBlog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/zycin/" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      不忘初心  方得始终
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/zycin" target="_blank">Zycin</a> | <a class="rss" href="https://fastt.cn/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


    <div class="main-container">
      <div class="content-container" data-aos="fade-up">
        <div class="post-detail">
          <h2 class="post-title">模块化和npm</h2>
          <div class="post-date">2019-10-10</div>
          
          <div class="feature-container" style="background-image: url('https://fastt.cn/post-images/module-npm.jpg')">
          </div>
          
          <div class="post-content">
            <p>此篇文章介绍<br>
<strong><code>ES6的模块</code></strong> <strong><code>nodem模块</code></strong><br>
<code>CMD和AMD</code> <code>npm的使用</code><br>
begin enjoy👇</p>
<!-- more -->
<h1 id="模块化编程">模块化编程</h1>
<h2 id="什么是模块化">什么是模块化</h2>
<p>所有的语言平台，只要其具有以下特征，则我们说它是使用模块编程：</p>
<ul>
<li>文件作用域
<ul>
<li>也叫<mark>模块作用域</mark>，即模块文件具有<strong>封装性</strong>，文件内容只能在内部使用 而不是在外部访问</li>
</ul>
</li>
<li>加载与导出
<ul>
<li>使用专门的语法 导出接口列表：export语法、exports对象、module.exports等</li>
<li>使用专门的方法 加载模块文件：require、include、import等。</li>
</ul>
</li>
</ul>
<p>目前为止，关于前端 我们学过的规范或者规则有：</p>
<ul>
<li>核心语法ECMAScript支持的模块语法，ES6以后可以使用，但在Node中支持不足</li>
<li>第三方库 requireJS规范，适用于客户端浏览器环境的异步加载机制，让前端具备模块化编程的能力</li>
<li>第三方库 CommonJS规范，适用于服务端环境的模块同步加载机制，也是Node模块加载采用的规范</li>
</ul>
<h2 id="es6模块规范">ES6模块规范</h2>
<p>es6新增语法用于模块化编程，使得前端工程的结构更为合理，维护性和扩展性增强，但目前在node中支持不足，如果一定要在node中使用es6的模块规范，可以通过babel生成。</p>
<h3 id="export语句">export语句</h3>
<p>在客户端环境中，文件默认没有作用域可以通过script直接引入。当文件中存在export或者import语法时则被认为是模块文件并且具有封装性，export用来声明开放接口的列表，具体用法如下：</p>
<ul>
<li>
<p>使用export直接导出定义，通过在创建该内容的代码块前面添加export关键字</p>
<pre><code class="language-javascript">//demo.js
//一个文件中可以存在多个export
export let foo = &quot;foo&quot;;
export function bar() {
    return &quot;bar&quot;;
};
</code></pre>
</li>
<li>
<p>export导出接口列表，以<code>{}</code>形式存放接口集合。此处的{}非对象的声明，只是集合语法</p>
<pre><code class="language-javascript">let foo = &quot;foo&quot;;
function bar () {
    return &quot;bar&quot;;
}

export {
    foo,
    bar
};  //此处不是对象的简洁属性，而是{}集合
    //不能使用{fo : foo, ba : bar}
    //可以使用as给接口设置别名

export {
    foo as fo,
    bar as ba,
}
</code></pre>
</li>
<li>
<p><code>export default</code>用来设置默认接口，这样在加载页面时就无需声明列表，直接接收即可。</p>
<pre><code class="language-javascript">//demo.js
let foo = &quot;foo&quot;;
function bar() {
    
}

//将foo作为默认接口导出
//export default foo;	
//export default只能出现一次 如果要返回多个接口 可以将它们放入对象中
export default {
    foo,
    bar,
} //此处为对象的简洁写法

//加载页面中使用
import demo from './demo.js';
console.dir(demo);	//demo为一个对象，包含多个接口

</code></pre>
</li>
<li>
<p>最后要注意，export语句必须处于模块文件顶层代码中，不能放在块级作用域中。</p>
</li>
</ul>
<h3 id="import-语句">import 语句</h3>
<p>页面中加载模块的script代码段需要声明type类型为module以区别普通的脚本；</p>
<p>其次要以服务器地址来请求模块文件，否则会被跨域拦截。</p>
<p>es6中使用import导入模块文件并接收接口列表。</p>
<ul>
<li>
<p><code>import {add, minus} from './math.js'</code> 其中相对路径中的<code>./</code>不可省略，<code>.js</code>后缀也不可省略 。</p>
<pre><code class="language-javascript">//math.js
export function add(x, y) {
    return x + y;
}

export function minus(x, y) {
    return x - y;
}
</code></pre>
<pre><code class="language-html">&lt;!--index.html必须以服务器地址来运行--&gt;
&lt;script type=&quot;module&quot;&gt;
	import {add, minu} from &quot;./math.js&quot;;
    console.log(add, minu);
&lt;/script&gt;
</code></pre>
</li>
<li>
<p><code>import {add, minus as min } from './math.js'</code> 导入时使用<code>as</code>重命名接口名称</p>
<pre><code class="language-javascript">//math.js
function add(x, y) {
    return x + y;
}

function minus(x, y) {
    return x - y;
}

export {
	add,
    minus
}
</code></pre>
<pre><code class="language-html">
&lt;script&gt;
	import {add as sum, minus as mus} math from './math.js';
    console.log(sum, mus);
&lt;/script&gt;

</code></pre>
</li>
<li>
<p><code>import * as math from './math.js'</code> 将模块成员存入mod对象中使用。</p>
<pre><code class="language-javascript">//math.js
function add(x, y) {
    return x + y;
}

function minus(x, y) {
    return x - y;
}

export {
	add,
    minus
}
</code></pre>
<pre><code class="language-html">&lt;script&gt;
	import * as math from './math.js';
    console.log(math); //{add, minus}
&lt;/script&gt;
</code></pre>
</li>
<li>
<p><code>import math from './math.js'</code> 使用了<code>export default</code>方式导出的接口</p>
<pre><code class="language-javascript">//math.js
export default {
    add (x, y) {
        return x + y;
    },
    
    minus (x, y) {
        return x - y;
    }
}
</code></pre>
<pre><code class="language-html">&lt;script&gt;
	import math from './math.js';
    console.log(math);
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="cmd模块规范">CMD模块规范</h2>
<p>CMD模块规范相对于AMD，得名来自<code>CommonJS</code>。CommonJS是适用于服务端的<mark>同步风格</mark>的模块加载机制，也是Node采用的规范。在CommonJS模块规范中，<strong>一个文件就是一个模块 具有封装性</strong>（作用域）。每个文件有一个<strong>隐式声明</strong>的<code>module.exports</code>对象，用来挂载接口。接下来在项目文件中，使用<code>require('模块路径')</code>载入该模块。</p>
<h3 id="exports的使用">exports的使用</h3>
<ul>
<li>
<p>在CommonJS中，每个模块文件都有一个隐式声明的<code>module.exports</code>对象以及一个引用它的<code>exports</code>对象，用来挂载接口 -  对象扩展；如果模块文件未设置module.exports或者exports则为一个<strong>空对象</strong>。</p>
<pre><code class="language-javascript">//mode.js
let foo = &quot;foo&quot;;

function bar() {

}

//模块文件具有封装性 - 文件作用域
console.log(&quot;hello world&quot;);

//每个模块文件都有一个module.exports对象 用来挂载接口
// module.exports.foo = foo;
// module.exports.bar = bar;
// console.log(module.exports);

//exports引用了module.exports对象 便于使用
// exports = module.exports;
console.log(exports == module.exports); //true

//因此可以直接简化导出接口列表的过程为：
exports.foo = foo;
exports.bar = bar;
</code></pre>
<p>在项目文件中，使用require('模块标识符')载入该模块，并定义变量来接收module.exports的内容：</p>
<pre><code class="language-javascript">//index.js
const mode  = require('./mode');
console.log(mode);	//{foo : &quot;hello world&quot;, bar : function () {}}
</code></pre>
</li>
<li>
<p>除了扩展的方式外，我们还可以重写<code>module.exports</code>对象为一个新值，这样require接收到的即为该值，它主要有以下两点优势：</p>
<ul>
<li>当模块中 只有一个接口时 （例如 定义类的模块文件），可以直接将该类导出 而不是作为接口对象成员。</li>
<li>当模块中 接口较多时 可以将它们集合到一个对象中 然后作为<code>module.exports</code>的新值。</li>
</ul>
<pre><code class="language-javascript">//comm.Rectangle.js
//定义矩形操作类模块
class Rectangle {
    constructor(width, height) {
        this.w = width;
        this.h = height;
    }

    area() {
        return this.w * this.h;
    }

    perimter() {
        return 2 * (this.w + this.h);
    }
}

//重写module.exports对象为该接口内容
module.exports = Rectangle;   

/*
* 此处如果使用exports = Rectangle则无效
* 因为真正能够导出接口的是module.exports
* exports是因为引用module.exports而能导出接口
* 现在重置exports将使得其不再具备接口导出的能力

* 同理，module.exports重置后 也会使exports丧失挂载接口的能力
*/

//exports上挂载的一切接口都无效
exports.a = &quot;hello&quot;;
exports.b = &quot;world&quot;;
</code></pre>
<pre><code class="language-javascript">//index.js
const Rectangle = require(&quot;./comm.Rectangle.js&quot;);
console.log(Rectangle);	
</code></pre>
<p>对于<code>module.exports</code>或者exports导出的多接口，可以在项目文件中使用解构赋值的方式直接提取出来：</p>
<pre><code class="language-javascript">//comm.math.js
let x = 10,
    y = 20;

function add() {
    return x + y;
}

function minus() {
    return x - y;
}

module.exports = {
    add,
    minus,
}//此处的{}是一个对象，使用了简洁属性
</code></pre>
<pre><code class="language-javascript">let {add, minus} = require('./comm.math.js');
console.log(add, minus);
</code></pre>
</li>
</ul>
<h3 id="require的使用">require的使用</h3>
<p>在一些平台中，存在require()与require_once() 这样两个用于加载模块的函数；其中require()会重复加载被引入的文件（多次执行），而require_once()则在每次加载前验证当前是否已有加载的文件，如果已有则不再加载，也就是说每个文件最多只加载一次；而node中的require也是<strong>只加载一次</strong>。</p>
<pre><code class="language-php">//mode.php
echo &quot;hello world&quot;;

//index.php
require(&quot;mode.php&quot;);//输出 include
require(&quot;mode.php&quot;);//输出 include_once

require_once(&quot;mode.php&quot;);	//不再输出
require_once(&quot;mode.php&quot;);	//不再输出
</code></pre>
<pre><code class="language-javascript">//mode.js
console.log(&quot;hello world&quot;);

//index.js
require(&quot;./mode&quot;);	//只执行一次
require(&quot;./mode&quot;);
</code></pre>
<h2 id="amd模块规范">AMD模块规范</h2>
<p>requireJS 是AMD风格的模块开发规范，所谓<code>AMD</code>是指<mark>异步模块定义规范</mark>，它非常适用于客户端（浏览器）环境。</p>
<p>模块开发是服务端必备的技术，随着前端发展和大规模的工程化应用，嵌入页面的脚本越来越多，并且相互依赖，因此无论是项目的<strong>管理</strong>还是代码的<strong>重用</strong>， 都需要借助于模块化 以此增强项目的可维护性和扩展性。</p>
<p>之前在服务端Node中，使用了CommonJS的规范，也叫CMD同步模块定义规范。在CMD中，同步的线程去加载模块会产生阻塞，但是毕竟<mark>模块都在同一个服务器或者同一个项目中</mark>，加载不会有延迟 也就难以发现这种阻塞，除非模块加载发生错误，这种阻塞才显而易见。</p>
<pre><code class="language-javascript">//server.js
const fs = require(&quot;fs&quot;);	//核心模块 -&gt; node.exe
const template = require(&quot;art-template&quot;); //加载第三包 -&gt; ./node_modules/art-template
const demo = require(&quot;./demo&quot;);//自定义模块 -&gt; ./demo.js
</code></pre>
<p>在前端模块化开发中，由于需要远程请求服务端资源 <strong>传统的script同步请求 在网络不佳的情况下 容易产生阻塞</strong>，因此必须使用<mark>异步</mark>的方式加载：</p>
<pre><code class="language-html">&lt;script src=&quot;jquery.js&quot; async=&quot;true&quot;&gt;&lt;/script&gt;
</code></pre>
<p>​	如果要以异步方式加载，就要考虑文件和代码之间的依赖关系。之所以很多时候 我们以同步方式引入模块或者库文件，是因为后续代码的执行 必须依赖这个模块文件。现在 如果异步加载 势必要将依赖的代码 作为该模块加载完毕后的回调函数来执行，相当于这样：</p>
<pre><code class="language-html">&lt;script src=&quot;jquery.js&quot; async=&quot;true&quot; onload=&quot;todo();&quot;&gt;&lt;/script&gt;

&lt;script&gt;

   function todo() {
   	//所有依赖jquery的代码 必须在此处执行
   	
   }

&lt;/script&gt;
</code></pre>
<p>requireJS很好的解决了上述问题，并更加智能和高效。requireJS中，模块使用<code>define</code>定义，它有两个参数：</p>
<ul>
<li>一是该模块依赖的其他模块，需要先异步加载进来</li>
<li>另一个是模块的定义代码，作为其他依赖模块都加载完毕后的回调函数</li>
</ul>
<p>requireJS模块的封装性是通过<mark>函数作用域</mark>实现的，接下来 需要返回一个<strong>公有对象</strong>存储接口列表并返回。</p>
<pre><code class="language-javascript">//mode.js

//该模块依赖jquery，当jquery加载完毕后 执行回调并接收jquery为$对象

define(['jquery'], function ($) {
    //---模块核心代码---
    let foo = &quot;foo&quot;;
    function bar() {};

    //---返回公有接口---
    return {
        foo, 
        bar
    } //使用简洁属性 模拟es6 exports导出的接口列表
});
</code></pre>
<p>定义好的模块和接口，接下来使用require函数引入，在require引入之前 需要使用<code>require.config()</code>配置模块和文件路径的映射 这样才能更好的加载和使用模块。</p>
<pre><code class="language-html">&lt;!--index.html中 首先载入require库文件--&gt;
&lt;script src=&quot;require.js&quot; async=&quot;true&quot;&gt;&lt;/script&gt;
//如果页面中的js作为外链文件 还可以声明data-main属性
&lt;script src=&quot;require.js&quot; async=&quot;true&quot; data-main=&quot;js/index&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-javascript">//index.js
require.config({
    baseUrl : &quot;./modules&quot;,	//模块根目录
    paths : {
        jquery : &quot;./jquery-2.0.2.min&quot;,	//可以省略js
        foo : &quot;foo&quot;
    }
});

//依次载入依赖的模块 然后执行页面代码
require([&quot;foo&quot;, &quot;jquery&quot;], function (f, $) {
    console.log(f, $);
    //页面特效的代码

});
</code></pre>
<h1 id="node模块系统">node模块系统</h1>
<p>node中使用的模块系统包含以下几种：</p>
<p>​	1) 核心模块：fs、http、url、querystring等</p>
<p>​	2) 第三方模块：使用npm从外部下载安装的模块，例如 art-template</p>
<p>​	3) 自定义模块：用户自己定义的模块文件，例如 math.js、mode.js等</p>
<p>而require在引入上述模块时，可以传入两种格式的模块标识：路径形式和包名</p>
<p>​	<code>require('模块标识符')</code></p>
<ul>
<li>
<p>当传入了一个路径时（以**./<strong>或者</strong>../**开头） 表示加载按照路径加载文件 一般用于自定义模块中。</p>
</li>
<li>
<p>当传入一个模块名时，就是参数中只有名称时 表示加载核心模块或者第三方模块。此时的模块文件是存在于Node核心文件（nodex.exe）中或者使用npm下载的node_modules目录中。</p>
<ul>
<li>
<p><code>require('fs')</code>加载核心模块fs，<code>fs.js</code>模块文件随着node环境被编译到<code>node.exe</code>文件中。这里可以通过源码查看到该文件。</p>
</li>
<li>
<p><code>require(&quot;art-template&quot;)</code> 加载第三方模块包，这里的art-template模块是存储于npm下载的包里面</p>
<p>接下来引入包时 它有一套明确的查找机制：</p>
<ol>
<li>首先查找当前目录的node_modules，定位<code>node_modules/包名/libs/package.json</code>包说明文件</li>
<li>查找配置项main，main用于指定包的入口文件，该文件用于调度包资源 并返回一个接口对象</li>
</ol>
<p>同理，我们使用npm安装jquery，查看它的package.json文件 找到main配置的入口文件；再接下来 我们可以自定义包 并使用require加载该包。注意require中传入的是包名。</p>
<ol>
<li>
<p>如果上述规则不能有效的运行，例如 package.json不存在或者没有main项，或者main指定文件不存在， 此时它还有一个备选项 就是直接找到包中的<code>index.js</code>作为默认入口文件。</p>
</li>
<li>
<p>上述条件都不成立时，它会沿着上级目录层层查找node_modules 直到磁盘根目录为止。也就是说存在于项目顶层目录node_modules中的模块 可以在所有的项目文件中使用require(包名)导入。因此 建议将node_modules放置于项目<strong>根目录</strong>中。</p>
</li>
</ol>
<pre><code class="language-shell">a
	node_modules/art-template
b
	require(&quot;art-template&quot;);	//找不到 除非使用路径查找
	require(&quot;../a/node_modules/art-template/index.js&quot;); //可以找到
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="packagejson">package.json</h1>
<p><code>package.json</code>是包说明文件，可用于项目中 用来添加项目描述以及管理项目中需要依赖的包。<code>package.json</code>文件可以通过<code>npm init</code>自动生成，该命令会以<strong>向导</strong>的方式提示基本的配置项。</p>
<pre><code class="language-shell">#在控制台执行npm init
d:\Wamp\WWW\node\day3\web&gt;npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.
See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt;` afterwards to install a package and
save it as a dependency in the package.json file.
Press ^C at any time to quit.

package name: (web) web
version: (1.0.0) 0.0.1
description: demo app
entry point: (index.js) inidex.js
test command:
git repository:
keywords:
author: lautin
license: (ISC)
About to write to d:\Wamp\WWW\node\day3\web\package.json:

{
  &quot;name&quot;: &quot;web&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;description&quot;: &quot;demo app&quot;,
  &quot;main&quot;: &quot;inidex.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;build&quot;: &quot;node server.js&quot;,
  },
  &quot;author&quot;: &quot;lautin&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}

Is this OK? (yes) yes
</code></pre>
<ul>
<li>name</li>
<li>version</li>
<li>description</li>
<li>main</li>
<li>author</li>
<li>license</li>
</ul>
<h2 id="scripts">scripts</h2>
<p><code>package.json</code>文件中的<code>scripts</code>字段用来定义脚本命令，所有的脚本命令都是shell的可执行命令。</p>
<p><code>scripts</code>为一个对象，它的每个属性对应一段要运行的脚本。例如，上面<code>build</code>命令对应的脚本是&quot;node server.js&quot;。接下来使用<code>npm run build</code>即可实现&quot;node server.js&quot;的效果。</p>
<p>每当执行**<code>npm run</code>**就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>
<pre><code class="language-shell">$ npm run build #等同于下面
$ node server.js
</code></pre>
<h3 id="如何编写shell">如何编写shell</h3>
<ul>
<li><strong>.bin</strong>中的可用程序</li>
</ul>
<p><code>node/modules/.bin</code>目录中存放了当前项目依赖中所有的命令行工具，而在<code>npm run</code>新建的Shell中，会将当前目录下<code>node_modules/.bin</code>目录加入<code>PATH</code>变量，执行结束后再将<code>PATH</code>变量恢复原样。</p>
<p>这就意味着，可以在scripts中直接引用<code>.bin</code>目录中的命令行工具，而无需设置它们的路径。</p>
<pre><code class="language-json">{
    &quot;build&quot; : &quot;gulp html&quot;, //不用写成下面那样
	&quot;build&quot; : &quot;./node_modules/.bin/gulp html&quot;
}
</code></pre>
<ul>
<li>使用通配符</li>
</ul>
<p>**<code>*</code>**表示任意文件名，<code>**</code>表示任意一层子目录。</p>
<p>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。</p>
<pre><code class="language-json">{
    &quot;test&quot;: &quot;tap test/\*.js&quot;
}
</code></pre>
<ul>
<li>使用内部变量</li>
</ul>
<p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p>
<p>首先，通过<code>npm_package_</code>前缀可以拿到<code>package.json</code>里面的字段。比如，下面是一个<code>package.json</code>。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;foo&quot;, 
  &quot;version&quot;: &quot;1.2.5&quot;,
  &quot;scripts&quot;: {
    &quot;view&quot;: &quot;node view.js&quot;
  }
}
</code></pre>
<p>那么，变量<code>npm_package_name</code>返回<code>foo</code>，变量<code>npm_package_version</code>返回<code>1.2.5</code>。</p>
<pre><code class="language-javascript">// view.js
console.log(process.env.npm_package_name); // foo
console.log(process.env.npm_package_version); // 1.2.5
</code></pre>
<p>上面代码中我们通过环境变量<code>process.env</code>对象拿到<code>package.json</code>的字段值。因为是临时PATH，所以只在npm脚本运行时才有效。如果是Bash脚本可以用<code>$npm_package_name</code>和<code>$npm_package_version</code>取到这两个值。</p>
<p><code>npm_package_</code>前缀也支持嵌套的<code>package.json</code>字段。</p>
<pre><code class="language-javascript">{
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;xxx&quot;
  },
  &quot;scripts&quot;: {
    &quot;view&quot;: &quot;echo $npm_package_repository_type&quot;
  }
}
</code></pre>
<p>上面代码中，<code>repository</code>字段的<code>type</code>属性，可以通过<code>npm_package_repository_type</code>取到。</p>
<p>下面是另外一个例子。</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
  		&quot;install&quot;: &quot;foo.js&quot;
	}
}
</code></pre>
<p>上面代码中，<code>npm_package_scripts_install</code>变量的值等于<code>foo.js</code>。</p>
<p>然后，npm 脚本还可以通过<code>npm_config_</code>前缀，拿到 npm 的配置变量，即<code>npm config get xxx</code>命令返回的值。比如，当前模块的发行标签，可以通过<code>npm_config_tag</code>取到。</p>
<pre><code class="language-json">{
    &quot;view&quot;: &quot;echo $npm_config_tag&quot;
}
</code></pre>
<p>注意，<code>package.json</code>里面的<code>config</code>对象，可以被环境变量覆盖。</p>
<pre><code class="language-json">{ 
  &quot;name&quot; : &quot;foo&quot;,
  &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; },
  &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; }
}
</code></pre>
<p>上面代码中，<code>npm_package_config_port</code>变量返回的是<code>8080</code>。这个值可以用下面的方法覆盖。</p>
<pre><code class="language-shell">$ npm config set foo:port 80
</code></pre>
<p>最后，<code>env</code>命令可以列出所有环境变量。</p>
<pre><code class="language-shell">&quot;env&quot;: &quot;env&quot;
</code></pre>
<ul>
<li>默认的脚本</li>
</ul>
<p>一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。</p>
<pre><code class="language-json">&quot;start&quot;: &quot;node server.js&quot;,
&quot;install&quot;: &quot;node-gyp rebuild&quot;
</code></pre>
<p>上面代码中，<code>npm run start</code>的默认值是<code>node server.js</code>，前提是项目根目录下有<code>server.js</code>这个脚本；<code>npm run install</code>的默认值是<code>node-gyp rebuild</code>，前提是项目根目录下有<code>binding.gyp</code>文件。</p>
<h3 id="执行npm脚本">执行npm脚本</h3>
<p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p>
<p>如果是并行执行（即同时的平行执行），可以使用<code>&amp;</code>符号。</p>
<pre><code class="language-shell">$ npm run script1.js &amp; npm run script2.js
</code></pre>
<p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&amp;&amp;</code>符号。</p>
<pre><code class="language-shell">$ npm run script1.js &amp;&amp; npm run script2.js
</code></pre>
<p>这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：<a href="https://github.com/paulpflug/script-runner">script-runner</a>、<a href="https://github.com/mysticatea/npm-run-all">npm-run-all</a>、<a href="https://github.com/coderaiser/redrun">redrun</a>。</p>
<p>四个常用的 npm 脚本有简写形式：</p>
<ul>
<li><code>npm start</code>是<code>npm run start</code></li>
<li><code>npm stop</code>是<code>npm run stop</code>的简写</li>
<li><code>npm test</code>是<code>npm run test</code>的简写</li>
<li><code>npm restart</code>是<code>npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start</code>的简写</li>
</ul>
<p>@link http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</p>
<h2 id="dependencies">dependencies</h2>
<p><code>package.json</code>中还有两个比较重要的配置项<code>dependencies</code>和<code>devDependencies</code>用来添加项目所依赖的包名，在安装包时可以通过<code>--save</code>和<code>--save-dev</code>参数可以将安装包写入这两个配置项中，例如：</p>
<pre><code class="language-shell"># 控制台使用npm
$ npm install art-template --save
$ npm install webpack --save-dev
</code></pre>
<p>然后<code>package.json</code>中会自动添加两行：</p>
<pre><code class="language-json">{
    &quot;dependencies&quot;: {
        &quot;art-template&quot;: &quot;^4.13.2&quot;
     },
    &quot;devDependencies&quot; : {
        &quot;webpack&quot; : &quot;^4.1.6&quot;
    }
}
</code></pre>
<ul>
<li>DevDependencies ：该配置项包含在<strong>开发时</strong>需要加载的包，而不是项目本身必须用到的包，例如 gulp、webpack用于打包一个项目，并不是属于项目自身。</li>
<li>dependencies : 项目开发以及上线运行必须加载的包，是项目功能核心的包。</li>
</ul>
<p>当项目中的node_modules丢失时 可以通过<code>npm install</code>一次性找回。<code>npm install</code>会依据<code>package.json</code>中**<code>dependencies</code>**选项挨个执行安装。因此 我们建议每个项目都添加一个<code>package.json</code></p>
<h1 id="package-lockjson">package-lock.json</h1>
<p><code>npm5+</code>的版本中，无需手动<code>--save</code>，它也会自动保存依赖信息。除此以外还加入了名为<code>package-lock.json</code>的文件。该文件在安装包时自动创建，保存了node_modules中所有包的信息：版本、描述以及<mark>下载地址</mark>，如此一来当再次安装该包时，它的速度就会显著提升。</p>
<p>lock文件被称为锁文件，主要是锁定包的版本，避免下次重装时以最新版本来下载。例如当前使用的是bootstrap3，当lock中记录了该版本时，下次安装就不会以最新的bootstrap4来下载，而是依然选择bt3。</p>
<h1 id="npm的使用">npm的使用</h1>
<h2 id="npm官网">npm官网</h2>
<p><a href="www.npmjs.com">官网</a>专门用来管理第三方包的平台，所有可用npm安装的包 都需要事先提交到该网站。接下来才能在用户代码中 使用npm下载。如果你有兴趣 也可以向该平台提交包。</p>
<p>@link <a href="https://www.cnblogs.com/chengxs/p/7651653.html">发布包的流程</a></p>
<h2 id="npm指令">npm指令</h2>
<p>npm是随着node一起安装的，当node安装完成npm也就有了， 并且写入了环境变量中。接下来在cmd窗口可以直接使用npm来执行命令：</p>
<ul>
<li>
<p><code>npm --version</code></p>
<ul>
<li>查看npm版本信息</li>
</ul>
</li>
<li>
<p><code>npm help</code></p>
<ul>
<li>查看使用帮助信息，命令列表</li>
<li>命令手册 <code>npm install--help</code></li>
</ul>
</li>
<li>
<p><code>npm install npm --global</code></p>
<ul>
<li>升级npm</li>
<li>需要全局使用的包，必须全局安装，它会将包下载到一个已经写入了环境变量的位置，例如：<code>C:\Users\admin\AppData\Roaming\npm\node_modules</code> 接下来在任意位置即可使用该包。</li>
</ul>
</li>
<li>
<p><code>npm init</code></p>
<ul>
<li>
<p>以向导形式 初始化<code>package.json</code>文件</p>
</li>
<li>
<p><code>npm init -y</code> 则是跳过向导  使用默认值快速生成<code>package.json</code></p>
</li>
</ul>
</li>
<li>
<p><code>npm install</code></p>
<ul>
<li>
<p>一次性安装 所有<code>depenencies</code>中的依赖包</p>
</li>
<li>
<p>简写形式 <code>npm i</code></p>
</li>
</ul>
</li>
<li>
<p><code>npm install 包名</code></p>
<ul>
<li>安装指定的包到node_modules中</li>
<li>简写形式 <code>npm i 包名</code></li>
</ul>
</li>
<li>
<p><code>npm install 包名 --save</code></p>
<ul>
<li>安装并将写包写入项目的依赖中</li>
<li>简写形式 <code>npm i 包名 -S</code></li>
</ul>
</li>
<li>
<p><code>npm install 包名 --save-dev</code></p>
<ul>
<li>安装并将包写入开发依赖环境中</li>
<li>简写形式 <code>npm i 包名 -D</code></li>
</ul>
</li>
<li>
<p><code>npm uninstall 包名</code></p>
<ul>
<li>删除一个包，保留依赖项</li>
<li>简写形式 <code>npm un 包名</code></li>
<li>别名：rm</li>
</ul>
</li>
<li>
<p><code>npm uninstall 包名--save</code></p>
<ul>
<li>删除一个包以及依赖项</li>
<li>简写形式 <code>npm un 包名 -S</code></li>
</ul>
</li>
</ul>
<h2 id="npm配置">npm配置</h2>
<ul>
<li>
<p>使用<code>npm config list</code>查看npm的基本配置信息</p>
<p>它包括有<code>cli configs</code>、<code>userconfig</code>、<code>builtin config</code>几级配置，通常修改userConfig的配置。userconfig配置文件在<code>c:/users/admin/.npmrc.</code>文件中，可以直接修改该文件来设置用户配置项</p>
</li>
<li>
<p>使用<code>npm config list -l</code>查看npm配置的详细信息</p>
</li>
<li>
<p><code>npm config get key</code>  读取一个配置项的值</p>
</li>
<li>
<p><code>npm config set key value</code> 设置一个配置项的值</p>
</li>
</ul>
<h1 id="npx的使用">npx的使用</h1>
<p>npx是npm5.2之后发布的一个命令。官网说它是<code>execute npm package binaries</code>，就是执行npm依赖包的二进制文件，简而言之，就是我们可以使用npx来执行各种命令。<br>
npx官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fnpx">https://www.npmjs.com/package/npx</a></p>
<h2 id="加载脚本">加载脚本</h2>
<p>当我们在安装一个命令行的工具包时，想要在本地（当前目录）执行它时，什么都不做时是不能运行的：</p>
<pre><code class="language-shell">$ npm i -D mocha
$ mocha --version
</code></pre>
<p>想要在本地能够执行它的命令，通常需要符合以下三种情况：</p>
<ul>
<li>
<p>全局安装该包，自动下载到已添加环境变量的位置，可以在任意目录下使用该包</p>
<pre><code class="language-shell">$ npm i mocha --global
</code></pre>
</li>
<li>
<p>在命令行中找到该模块的二进制文件运行，通常是<code>node_modules/包名/bin/</code>目录</p>
<pre><code class="language-shell">$ cd node_modules/mocha/bin
$ mocha --version
</code></pre>
</li>
<li>
<p>当前项目的<code>package.json</code>文件中创建npm脚本，即<code>scripts</code>中设置一条执行该包的命令。原理是<code>npm run</code>执行时<code>.bin</code>目录会动态添加到环境变量中。</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
  		&quot;findmocha&quot;: &quot;mocha --version&quot;,
	}
}
</code></pre>
<pre><code class="language-shell">$ npm run findmocha
</code></pre>
</li>
</ul>
<p><strong>使用npx可以在命令行直接执行本地已安装的依赖包命令，不用在scripts脚本写入命令</strong>，也不用麻烦的去找本地脚本。</p>
<pre><code class="language-shell">$ npm i -D mocha
$ npx mocha --version
</code></pre>
<p>npx的原理，就是在运行它时，执行下列流程：</p>
<ol>
<li>
<p>去<code>node_modules/.bin</code>路径检查npx后的命令是否存在，找到之后执行；</p>
</li>
<li>
<p>找不到，就去环境变量<code>$PATH</code>里面，检查npx后的命令是否存在，找到之后执行;</p>
</li>
<li>
<p>还是找不到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。</p>
</li>
</ol>
<h2 id="使用场景">使用场景</h2>
<h3 id="一次性的命令">一次性的命令</h3>
<p>不同全局安装，直接在命令行执行一次性命令，例如</p>
<pre><code class="language-undefined">npx create-react-app my-react-app
</code></pre>
<p>npx将<code>create-react-app</code>下载到一个临时目录，使用以后再删除。<br>
每次运行这个命令，都会重新下载依赖包，运行后删除。</p>
<h3 id="切换node版本">切换node版本</h3>
<p>当你想要运行的命令不兼容当前的nodejs版本，可以通过npx来切换版本，指定某个版本的 Node 来运行命令。</p>
<p>npx的-p选项指定要安装的包，并将其添加到正在运行的$PATH中，例如：</p>
<pre><code class="language-ruby"> npx node@6 -v
 npx node@7 -v
 npx node@8 -v
</code></pre>
<p>以上的命令，会自动下载需要的node，执行完命令后删除。</p>
<h3 id="开启服务">开启服务</h3>
<pre><code class="language-shell">npx http-server    #默认返回根目录下index.html
npx http-server -p 3000  #指定端口
</code></pre>
<h2 id="常用指令">常用指令</h2>
<p>可以单独安装npx：</p>
<pre><code class="language-undefined">npm install -g npx
</code></pre>
<ul>
<li>-p</li>
</ul>
<p>-p参数用于指定 npx 所要安装的模块</p>
<pre><code class="language-css">npx -p node@6 node -v
</code></pre>
<ul>
<li>--no-install</li>
</ul>
<p>强制使用本地模块，不下载远程模块，如果本地不存在该模块，就会报错。</p>
<ul>
<li>--ignore-existing</li>
</ul>
<p>忽略本地的同名模块，强制安装使用远程模块</p>
<h1 id="cnpm代理">cnpm代理</h1>
<p>npm远程服务器存放于国外，即便国内有CDN也会比较慢，因此建议使用时配置国内的镜像地址 。</p>
<p>@link http://npm.taobao.org</p>
<p>这是一个完整 <code>npmjs.org</code> 镜像，你可以用此代替官方版本(<strong>只读</strong>)，同步频率目前为 <strong>10分钟</strong> 一次 以保证尽量与官方服务同步。</p>
<p>1）全局安装cnpm</p>
<pre><code class="language-shell">&gt; npm install cnpm --global
</code></pre>
<p>2）使用cnpm安装包</p>
<pre><code class="language-shell"># 使用cnpm安装art-template
&gt; cnpm install art-template
√ Installed 1 packages
√ Linked 27 latest versions
√ Run 0 scripts
√ All packages installed (30 packages installed from npm registry, used 16s(network 16s), speed 69.44kB/s, json 28(79.46kB), tarball 1.01MB)
</code></pre>
<p>如果不想安装cnmp服务 而又想使用其镜像服务器下载包，则可以通过<code>--registry</code>来设置</p>
<pre><code class="language-shell">&gt; npm install art-template --registry=https://registry.npm.taobao.org
</code></pre>
<p>或者直接修改npm配置项中下载入口地址：</p>
<pre><code class="language-shell">&gt; npm config set registry https://registry.npm.taobao.org
#查看npm配置项信息
&gt; npm config list
</code></pre>
<pre><code class="language-shell">&gt; npm config list -l
</code></pre>
<hr>
<p align="right">posted @ Zycin (非转载 来自个人学习资料整理)</p>
          </div>
          
          <div class="tag-container">
            
            <a href="https://fastt.cn/tag/node" class="tag">
              node
            </a>
            
            <a href="https://fastt.cn/tag/npm" class="tag">
              npm
            </a>
            
            <a href="https://fastt.cn/tag/module" class="tag">
              module
            </a>
            
          </div>
          


          
          <div class="next-post">
            
            <div class="prev">
              <div class="post-page">上一篇</div>
              <a href="https://fastt.cn/post/promise">
                <h3 class="post-title">
                  Promise异步编程
                </h3>
              </a>
            </div>
            
            
            <div class="next">
              <div class="post-page">下一篇</div>
              <a href="https://fastt.cn/post/es6">
                <h3 class="post-title">
                  ES6的语法
                </h3>
              </a>
            </div>
            
          </div>
          

          
          
          <div id="gitalk-container" data-aos="fade-in"></div>
          

          
          

        </div>

      </div>
    </div>
  </div>

  <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'f9c4cb98113788bb94e1',
        clientSecret: 'd271ed343d3af9b71c24dff543d9c3e1e4d70a4b',
        repo: 'zycin.github.io',
        owner: 'zycin',
        admin: ['zycin'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




</body>

</html>