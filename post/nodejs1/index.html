<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>nodeJS学习一 | Zycin | GeekBlog</title>
<meta name="description" content="不忘初心  方得始终">
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://www.fastt.cn/favicon.ico?v=1571466253459">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://www.fastt.cn/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://www.fastt.cn">
        <img src="https://www.fastt.cn/images/avatar.png?v=1571466253459" class="site-logo">
        <h1 class="site-title">Zycin | GeekBlog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/zycin/" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      不忘初心  方得始终
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/zycin" target="_blank">Zycin</a> | <a class="rss" href="https://www.fastt.cn/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">nodeJS学习一</h2>
            <div class="post-date">2019-10-18</div>
            
              <div class="feature-container" style="background-image: url('https://www.fastt.cn/post-images/nodejs1.jpg')">
              </div>
            
            <div class="post-content">
              <p>👏 👏 👏 <strong>NodeJs</strong> 第一阶段<br>
nodejs的简介以及基本语法教程</p>
<!-- more -->
<h1 id="什么是nodejs">什么是nodeJS</h1>
<p>node.js是一个基于<code>Chrome V8</code>引擎的Javascript运行环境，<strong>node.js由ECMAScript和核心模块组成</strong>，没有浏览器环境的API，即DOM和BOM。</p>
<p><strong>Node.js使用了一个事件驱动，非阻塞的I/O模型</strong>，使其轻量又高效 - Node.js诞生的初衷。</p>
<p>在此之前像C/PHP等语言平台 都是同步线程的业务模型，很多时候会产生等待和死锁。因此 有人希望能够创建一个异步多线程的业务模型 来提高服务端的执行效率 以应对更多的并发业务。如果要实现异步业务流 就必须借助回调函数 类似于客户端Ajax的线程模型 - 采用了异步回调的机制。</p>
<pre><code class="language-javascript">//在浏览器解析时 给DOM对象绑定事件处理函数 - 回调函数
xhr.onloadend = function () {
    //ajax执行完毕回调该事件
    
}
xhr.send();
</code></pre>
<p>node.js的<strong>包管理器<code>npm</code></strong>(<code>node package manager</code>)，是一个在线的包托管平台。很多语言平台都有自己的开发生态。例如PHP中的composer依赖管理平台，npm就是nodejs语言平台包依赖管理工具，也是全球最大的开源生态系统。</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559789942793.png" alt="1559789942793"></figure>
<p>node.js的包管理器npm，是全球最大的开源库生态系统。</p>
<h1 id="nodejs环境安装">nodeJS环境安装</h1>
<p>进入官网nodejs.cn，点击下载菜单，或者直接进入 @link http://nodejs.cn/download/</p>
<p>window下支持图形界面的安装：</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559790544745.png" alt="1559790544745"></figure>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559790691006.png" alt="1559790691006"></figure>
<p>node.ext是node环境启动文件，内置了编译号的node核心模块，所有的node代码都要使用node.exe文件来执行。类似于PHP代码执行时需要安装php.exe的PHP引擎。</p>
<p>安装时，会将<code>node.exe</code>可执行程序自动写入环境变量。也就说接下来我们可以在任意目录中，使用node指令：</p>
<p><code>node -v</code>用来查看node的安装版本：</p>
<figure data-type="image" tabindex="4"><img src="D:%5CWamp%5CWWW%5Csz0812%5Cday30%5Cresource%5C1569207954482.png" alt="1569207954482"></figure>
<pre><code class="language-shell">&gt; node -v
</code></pre>
<h1 id="开始使用nodejs">开始使用nodeJS</h1>
<p>node平台是ECMAScript核心语法实现，因此所有的代码都要写在<code>.js</code>的文件中。在浏览器环境中，js文件需要被引入HTML中才能运行。而node中，js文件是直接运行的。</p>
<h2 id="解释执行node代码">解释执行node代码</h2>
<ul>
<li>
<p>创建js脚本文件，使用控制台输出</p>
<pre><code class="language-javascript">//index.js
console.log(&quot;hello world&quot;);//内置的console模块
</code></pre>
</li>
<li>
<p>打开命令行 进入脚本文件位置</p>
<ul>
<li>
<p>系统<code>cmd</code>（comand）中 使用<code>cd</code>（change directory）命令切换到脚本所在目录</p>
<figure data-type="image" tabindex="5"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557477853030.png" alt="1557477853030"></figure>
</li>
<li>
<p>在文件系统中进入文件所在目录位置，按住<code>shift键 + 右键</code> --&gt; <code>在此处打开PS窗口</code></p>
<figure data-type="image" tabindex="6"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557477930187.png" alt="1557477930187"></figure>
<figure data-type="image" tabindex="7"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557477992482.png" alt="1557477992482"></figure>
</li>
<li>
<p>在编辑器中安装<code>Terminal</code>（终端）扩展，进入应用商店中搜索<code>Terminal</code>即可。例如：vs code中安装Termimal插件。如果是NetBeans IDE等 需要安装<code>cgywin</code>插件。</p>
<figure data-type="image" tabindex="8"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557478246352.png" alt="1557478246352"></figure>
<p>接下来 在文件工作区中 鼠标右键 <code>open in integrated Terminal</code> 则会显示如下终端界面：</p>
<figure data-type="image" tabindex="9"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557478997363.png" alt="1557478997363"></figure>
</li>
</ul>
</li>
<li>
<p>使用<code>node</code> 指令运行该文件 <code>node index.js</code> 	<img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557480089425.png" alt="1557480089425"></p>
<ul>
<li>
<p>注意文件名不能是<code>node.js</code>  否则不执行。<code>node.js</code>文件导致其他文件无法正常执行和输出</p>
</li>
<li>
<p>node是服务器环境，它虽然采用<code>ECMAScript</code>核心语法，但是没有浏览器宿主环境的接口</p>
<pre><code class="language-javascript">//index.js
console.log(window);	//window is not defined
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="使用node读写文件">使用node读写文件</h2>
<p>作为客户端环境的Javascript无法操作文件；但是Node中，通过内置的核心API，使其具备访问文件的能力；</p>
<p>node的核心模块fs（file system）专门用来读写文件内容，我们只需在用到的时候使用require载入即可。</p>
<pre><code class="language-javascript">const fs = require('fs');	//require用于引入系统核心API文件
							//参数fs是固定标识 不可更改，
							//接收变量可根据个人习惯修改 但通常和核心文件同名
</code></pre>
<h3 id="读取文件的内容">读取文件的内容</h3>
<ul>
<li>
<p>加载文件系统的核心API，fs（file-system）</p>
<p><code>const fs = require('fs')</code></p>
</li>
<li>
<p>使用<code>fs.readFile()</code>读取一个文件的内容</p>
<p><code>fs.readFile(filename, [option], callback)</code>   callback有两个参数：data, error</p>
<ul>
<li>
<p>读取<strong>成功</strong>时</p>
<ul>
<li>data为文件数据。文件以二进制数据存储，这里返回的<mark>是经过转化</mark>的十六进制数据；无论二进制还是十六进制，它们都是机器码，如果要转化成人类可识别的语言 则使用data.toString()方法转化。</li>
<li>error则为null</li>
</ul>
</li>
<li>
<p>读取<strong>失败</strong>时</p>
<ul>
<li>data为<strong>null</strong>；</li>
<li>error为一个错误对象 存储了错误信息 当读取一个不存在的文件时会产生错误</li>
</ul>
</li>
</ul>
</li>
<li>
<p>完整的代码示例：</p>
<pre><code class="language-javascript">//载入系统核心类库
const fs = require(&quot;fs&quot;);
fs.readFile(&quot;foo.txt&quot;, (err, buffer) =&gt; {//服务端通常不涉及this绑定 推荐使用箭头函数
    //检测是否有错误
    if (err) console.dir(err);
   else {
       //返回二进制数据 因为内容太长 转化为十六进制
       console.log(buffer); //&lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;
       //使用toString()转化为字符串
       console.log(buffer.toString());
       //或者设置第二参数，指定返回内容的编码类型'utf-8'
   }
})
</code></pre>
<p>同样 需要注意的是使用node编写的js代码 只能运行于node环境中 而不能运行于浏览器环境。从本质上来说浏览器中javascript引擎和node引擎加载了不同的es扩展。</p>
<pre><code class="language-html">&lt;!--在HTML中引入node代码--&gt;
&lt;script src=&quot;fs.js&quot;&gt;&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="10"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557592149210.png" alt="1557592149210"></figure>
</li>
</ul>
<h3 id="向文件写入内容">向文件写入内容</h3>
<ul>
<li>
<p>载入核心的文件系统API,fs</p>
</li>
<li>
<p>使用<code>fs.writeFile()</code>写入一个文件内容</p>
<ul>
<li>
<p><code>fs.writeFile(filename, content, callback)</code>  filename为写入文件名，content为文件内容 callback是执行结果的回调函数</p>
</li>
<li>
<p>callback回调函数拥有一个参数error，当执行成功 error为null，失败则为一个错误对象</p>
</li>
<li>
<p>给已有文件写入内容会覆盖，新文件则创建之；如果文件名包含有特殊字符：<code>*/\^&amp;</code>等会产生错误</p>
<figure data-type="image" tabindex="11"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557592632647.png" alt="1557592632647"></figure>
</li>
</ul>
</li>
<li>
<p>完整的示例代码：</p>
<pre><code class="language-javascript">const fs = require(&quot;fs&quot;);
//如果已有文件则覆盖，否则创建新的文件
fs.writeFile(&quot;*.txt&quot;, &quot;hello nodeJS&quot;, (err) =&gt; {
    
});
</code></pre>
</li>
</ul>
<h1 id="创建http服务器">创建http服务器</h1>
<ol>
<li>
<p>引入核心的系统API - http模块</p>
<pre><code class="language-javascript">const http = require('http');
</code></pre>
</li>
<li>
<p>使用createServer()方法创建一个服务器</p>
<pre><code class="language-javascript">const server = http.createServer();
</code></pre>
</li>
<li>
<p>启动服务器并设置http服务的监听端口</p>
<pre><code class="language-javascript">server.listen(8000, (err) =&gt; {
    //发生错误返回一个错误对象
    if (err) console.dir(err);
    console.log('服务器已经启动');
});
</code></pre>
<p>现在，使用<code>cmd</code> 进入文件所在位置，执行<code>node 文件名</code> 即可实现类似Apache Web服务的启动。</p>
<p>类似于Apache中进入http.conf中修改<code>listen 8000</code> ，然后命令行中运行<code>httpd -k start</code>来启动服务</p>
<figure data-type="image" tabindex="12"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556955505900.png" alt="启动服务"></figure>
<p>注意端口号的设置应避免重复，当端口号被占用时服务无法启动。一个简单的示例 可以在<strong>另一个</strong>cmd窗口中运行该服务，由于使用了同样的端口号，则再次启动会失败。</p>
<figure data-type="image" tabindex="13"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556956433519.png" alt="1556956433519"></figure>
<p>尽管服务已经启动，但还未添加任何对请求的处理，当在地址栏输入<code>127.0.0.1:8000</code>时，客户端未收到任何来自服务端的响应 始终处于<strong>等待状态</strong>。</p>
<figure data-type="image" tabindex="14"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556956221789.png" alt="发送请求"></figure>
</li>
<li>
<p>设置请求的响应处理</p>
<p>node.js是异步非阻塞的I/O处理，几乎所有的操作都伴随异步行为；而异步的编码风格需要在异步行为<strong>之前</strong>使用<strong>回调函数</strong>来完成处理。</p>
<p>接下来注册一个request事件的回调函数监听来自浏览器的请求并响应结果。</p>
<pre><code class="language-javascript">//回调函数中的request为请求对象 response为响应对象
server.on('request', (request, response) =&gt; {
    //一个HTTP请求 为一次客户端和服务器的会话
    //所谓的会话就是对话 需要你来我往 相互传送
    //对于客户端请求内容 可通过request对象查询
    //服务端的响应 需要使用response对象来返回
    console.log(&quot;收到客户端请求了&quot;);
});
</code></pre>
<p><strong>完整的代码示意</strong></p>
<pre><code class="language-javascript">//引入系统核心模块http
const http = require(&quot;http&quot;);

//创建http访问的服务器
const server = http.createServer();

//启动前添加监听请求的回调函数 处理浏览器请求 给予响应
server.on(&quot;request&quot;, (request, response) =&gt; {
    console.log(&quot;收到客户端请求了&quot;);
    //使用response设置响应正文
    response.write(&quot;hello world&quot;);
    response.write(&quot;and more...&quot;);
    //结束响应否则客户端会一直等待
    response.end();
});

//启动并设置监听端口
server.listen(8000, (err) =&gt; {
    if (err) console.dir(err);
    else {
        console.log(&quot;服务已启动...&quot;);
    }
})

</code></pre>
<h2 id="request对象">request对象</h2>
<p>request对象的url属性用来获取http请求中的路径，也就是端口号后面以<code>/</code>开头的那部分，形如</p>
<p><code>127.0.0.1:8000</code> 路径为<code>/</code></p>
<p><code>127.0.0.1:8000/a.html</code>  路径为<code>/a.html</code></p>
<p><code>127.0.0.1:8000/foo/a.html</code>  路径为<code>/foo/a.html</code></p>
<p><code>127.0.0.1:8000/foo/a.html?id=9527</code> 路径为<code>/foo/a.html?id=9527</code></p>
<p>​	在Apache中 有初始化的DocumentRoot配置 指定<strong>站点根目录</strong>，接下来会由请求路径对应到一个具体的资源文件中；而node.js则是自己定制的服务器，这都需要我们手动处理。</p>
<p>​	这里 我们首先解决一个基本的问题 就是如何响应一个文件给浏览器。无论是网页文件还是图片、视频等媒体资源 文件本质上都是二进制数据，还是返回字符串内容给浏览器，该内容是从文件中读取出来的。</p>
<pre><code class="language-javascript">//引入系统核心模块
const http = require(&quot;http&quot;),
    fs = require(&quot;fs&quot;);

//创建一个服务器
const server = http.createServer();

const DOCUMENT_ROOT = &quot;D:/Wamp/WWW&quot;;

//监听客户端请求
server.on(&quot;request&quot;, (request, response) =&gt; {
    let filename;
    //request为请求对象存放请求信息
    // console.dir(request);
    //请求方式 解析参数
    console.log(request.method); //GET
    //请求地址 处理响应
    console.log(request.url); // '/'
    //请求头信息 检测请求
    console.dir(request.headers); //{...}

    //判断请求路径 响应站点下的文件
    //如果为根地址 则默认请求index
    if (request.url == &quot;/&quot;) {
        filename = &quot;index.html&quot;;
    } else {//路径中的特殊字符在http传输时经过编码 需要解码
        filename = decodeURIComponent(request.url);
    }

    fs.readFile(DOCUMENT_ROOT + &quot;/&quot; + filename, &quot;utf-8&quot;, (err, data) =&gt; {
        if (err) console.dir(err);
        response.write(data);
        response.end();
    });
    
});

//启动并设置端口
server.listen(8000, (err) =&gt; {
    if (err) console.dir(err);
    else {
        console.log(&quot;服务已经启动...&quot;);
    }
})
</code></pre>
<figure data-type="image" tabindex="15"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557665648110.png" alt="1557665648110"></figure>
<p>当在浏览器地址栏输入<code>127.0.0.1:8000</code>时，你会发现控制台打印的请求路径中还包括有<code>/favicon.ico</code>。或者我们在浏览器开发者工具的<code>网络</code>查看，你也会找到该请求。这是一个浏览器默认行为 目的是找到该页面的图标提供给<strong>title</strong>和<strong>收藏夹</strong>使用。</p>
<figure data-type="image" tabindex="16"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557665109015.png" alt="1557665109015"></figure>
<h2 id="response对象">response对象</h2>
<p>response对象用来返回响应的结果，它有几个基本的方法：</p>
<ul>
<li>
<p>response.setHeader()</p>
<p>用来设置响应头信息，用来告知浏览器返回结果的<strong>文本类型、内容编码、缓存控制、跨域资源共享</strong>等</p>
<p>不同的资源文件，对应不同的Content-Type值，在Content-Type中一般设置两项：</p>
<ul>
<li>
<p>文档类型</p>
<p>即常说的mime-type类型值，用来区别不同的网络资源，简单来说 就是指定文件数据格式，以便浏览器更好的去识别和解析它们。 @link http://tool.oschina.net/commons</p>
</li>
<li>
<p>编码类型</p>
<p>一般为字符数据才指定编码，如果是图片等二进制数据 则不需要指定编码类型。当响应内容包含中文时最好指定该值。</p>
</li>
</ul>
</li>
<li>
<p>response.write()</p>
<p>写入响应正文的方法，必须是二进制或者字符串数据。复合类型数据 必须转化成字符串才能用于http传输</p>
</li>
<li>
<p>response.end()</p>
<p>write()方法可以写入多次，但最终必须以end结束 否则客户端会一直等待；end()方法 也可结合write()一起使用 简化代码的输入。</p>
<pre><code class="language-javascript"></code></pre>
</li>
</ul>
<p>//引入系统核心模块http<br>
const http = require(&quot;http&quot;);</p>
<p>//创建http访问的服务器<br>
const server = http.createServer();</p>
<p>server.on(&quot;request&quot;, (req, res) =&gt; {</p>
<pre><code>   res.writeHead(200, {
       &quot;Content-Type&quot; : &quot;text/html;charset=utf-8&quot;,
   });
   
   res.write(&quot;&lt;h4&gt;NodeJS服务返回的结果&lt;/h4&gt;&quot;);
   
   //end方法结束响应并返回结果
   res.end();
</code></pre>
<p>});</p>
<p>//启动并设置监听端口<br>
server.listen(8000, (err) =&gt; {<br>
if (err) console.dir(err);<br>
else {<br>
console.log(&quot;服务已启动...&quot;);<br>
}<br>
});</p>
<pre><code>



</code></pre>
</li>
</ol>
<h1 id="模块化编程简介">模块化编程简介</h1>
<p>Node中的模块遵循es6模块定义的规范，但是不支持export和import的使用，转而使用exports和require.</p>
<ul>
<li>
<p>在ES6中 模块文件使用export语法关键字导出接口，然后使用import导入模块文件并接收模块方法；</p>
<p>而Node.js中 使用exports对象导出模块接口，使用require引入模块文件并接收exports对象内容；</p>
</li>
<li>
<p>es6模块中 import模块文件路径必须有<code>./</code>，且<code>.js</code>后缀名不可省略，而node中则不太一样，后面介绍。</p>
<p>但无论es6模块还是node模块，都是具有<strong>封装性</strong>，外部无法访问模块中的成员。</p>
</li>
</ul>
<h3 id="系统核心模块">系统核心模块</h3>
<p>系统核心模块是一个具名的模块文件，使用<code>require(模块名)</code>直接引入即可，并定义变量接收模块对象接口。</p>
<figure data-type="image" tabindex="17"><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557681125823.png" alt="1557681125823"></figure>
<h3 id="用户定义模块">用户定义模块</h3>
<ul>
<li>
<p>在node中使用CommonJS规范定义模块文件，也叫CMD模块加载，它使用module.exports导出模块接口</p>
<pre><code class="language-javascript">//demo.js
//使用commonJS规范定义的模块
//1| 控制台打印提示信息 检测是否加载成功
console.log(&quot;这是math模块文件&quot;);

//2| 定义模块文件内容，变量、函数、类等
//接下来在加载文件中使用这些成员 检测封装性
let foo = &quot;foo&quot;;

function bar() {
    return &quot;bar&quot;;
}

//3| 使用exports语法导出接口列表
module.exports = {
    foo, 
    bar,
}
</code></pre>
</li>
<li>
<p>使用require引入模块文件</p>
<p>使用require引入用户模块时，模块文件名的后缀名可以省略，但相对路径中的<code>./</code>则不可以省略</p>
<pre><code class="language-javascript">//1| 引入模块文件并检测是否有打印的提示信息
require(&quot;./demo&quot;);   //.js可以省略 但./不可省
                       //一旦省略则变成了系统模块
					   
//2| 在文件中直接引用模块成员，检测模块的封装性
console.log(foo, bar); //foo和bar未定义
                       //模块具有封装性，也叫文件作用域
</code></pre>
</li>
<li>
<p>定义接收模块接口的对象</p>
<p>require全局函数有返回值，它接收模块文件中 使用exports对象返回的接口，通常使用同名变量接收模块。</p>
<pre><code class="language-javascript">//3| 定义对象接收模块接口内容
const demo = require(&quot;./demo&quot;);
//返回模块接口对象
console.dir(demo);

//使用模块开放成员
console.log(demo.foo);
console.log(demo.bar());
</code></pre>
</li>
</ul>
<h1 id="nodemon工具">nodemon工具</h1>
<p><a href="https://www.npmjs.com/package/nodemon">https://www.npmjs.com/package/nodemon</a></p>
<p>使用<code>npm install -g nodemon</code>全局安装nodemon自动刷新</p>
<h1 id="inspector工具">inspector工具</h1>
<p>​</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://www.fastt.cn/tag/PVYubv9CN" class="tag">
                    node
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://www.fastt.cn/post/markdown">
                  <h3 class="post-title">
                    MarkDown语法教程
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'f9c4cb98113788bb94e1',
        clientSecret: 'd271ed343d3af9b71c24dff543d9c3e1e4d70a4b',
        repo: 'zycin.github.io',
        owner: 'zycin',
        admin: ['zycin'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
